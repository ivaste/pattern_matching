an overview of the coap protocol architecture, features and its extensions stefano ivancich department of information engineering (dei) university of padova, italy email: stefano.ivancich@studenti.unipd.it student id: 1227846  which rules the communication between web clients and web servers. it’s used mostly for transfer html documents between nodes. at its basis it is a textual requestresponse protocol where clients and servers exchange messages constituted by an header and an optional body. is a stateless protocol, that basically means that each request-response is independent and neither the client nor the server has to keep trace of the exchanged messages. this simplifies the implementation of the protocol and makes it more scalable. and is designed to favors the use of intermediaries or proxies, typically for caching or security purposes. it is appropriate for devices with relatively high computational power, but often it can be too demanding in terms of bandwidth and processing requirements for the constrained devices that we are considering in the iot scenario. so, a protocol called constrained application protocol (coap) defined in the rfc 7252 [2] was developed as a lightweight counterpart of http in order to simplify integration with the web but at the same time address the needs of constrained devices and constrained networks, indeed those kind of nodes usually carry 8-bit microcontrollers with very small amounts of rom/ram, while constrained networks generally suffer of high packet error rates and have an indicative throughput of 10s kbit/s. this protocol is used for machine-to-machine (m2m) communication and, as said before, is quite similar to http, but with some relevant differences. it uses smaller and simplified headers, supports asynchronous rest, publish/subscribe message exchanges, provides support for multicast, extremely low overhead, and is easy to implement for constrained environments. the aim of coap is not to indiscriminately compress the http protocol, but instead to provide a subgroup of rest in common with http that are optimized for m2m communications. in this work, we focus on the iot communication pro-  fig. 1: stefano ivancich in 2021 abstract—today (2021), several billions of devices are connected daily to the internet, so a very huge amount of a data is sent and managed every second. in the next years, it is expected that even more devices like sensors, actuators for domestic or industrial usage will connect to the internet. in this context, we review an http like protocol called constrained application protocol (coap) that was developed by the internet of engineering task (ietf) to work on constrained iot devices operating in lossy environments. although this protocol is lightweight and efficient compared to other iot protocols such as http or mqtt, it has some limitation in some scenarios, for example when strong reliability is needed or in streaming applications. for this reason we also overview, from the most recent literature some modifications, one is coap over tcp that guarantee reliability, another is coap-sc that has a good mechanism to handle with error and flow control that are crucial in streaming applications. index terms—coap, iot, tcp, udp, streaming, enhancements in coap  i. i ntroduction the hypertext transfer protocol (http) [1] is one of the most widely used application layer protocol for distributed, collaborative, hypermedia information systems,  1  or responses based on their method codes or response codes. both request and responses can be confirmable or non-confirmable. we can think of coap a two-layer protocol, one layer for messaging that deal with the transport layer and with asynchronous messages, and a request/response layer that manages request/response interactions through method and response codes. you can see this in fig. 2.  tocol coap; in particular, we overview its architecture, features and extensions. the report is structured as follows: in section ii we describe the communication problems in constrained networks, in section iii we give an overview of the coap protocol that tackle those problems, and in section iv we describe it’s message format, it’s transmission and semantic. in section v we describe the coap methods definitions, caching and proxying. in section vi we review some extension and modifications of the standard coap protocol. and finally in section vii we make some extra considerations on future developments and possible improvements. ii. c onstrained d evices and n etworks edge networks may operate in a huge variety of environments and conditions that requires a careful attention on their use. usually, data flowing throw edge networks are ultimately destined for the internet, so they should be designed with that transition in mind and therefore it makes some sense to emulate some ideas in iot edge network design. the so-called constrained networks are characterized as low-power and lossy networks (llns). those kinds of networks are used often in combination with constrained devices that, have limited processing and powers supply, in table 1 you can see a classification of constrained devices. llns are constrained because the cost, the limited nodes capabilities, limited power, limited spectrum, high density and interference. so they need smaller (compressed) headers and smaller payloads/packets to keep bit error rates low and permit media sharing. that’s where lightweight communication protocols like coap comes into play.  fig. 2: abstract layering of coap now we are going to explain these 2 layers in depth. a. messaging model the message layer is the bottom layer of coap and it deals with the exchange of messages over the transport layer, in the base case the udp datagrams, but in the following section we will see how it adapts to tcp. coap uses a binary header of fixed length (4 bytes), after which a compact binary options and the payload might follow. every message in coap has a 16-bit unique id used for the detection duplicates and for reliability, allowing an exchange of up to 250 messages per second. a message can be sent reliably if its type is confirmable (con), a response will be provided with the acknowledgement message (ack) type carrying the same message id or with the reset message (rst) if the recipient is not capable to handle/process the message that was sent. this process can be seen in fig. 3. a non-reliable message can be sent as nonconfirmable message (non) that won’t have any acknowledge response, but if the recipient has some troubles processing such message, it can reply with the reset message (rst). even though these kind of messages are not reliable, they carry a unique id. this process can be  iii. c onstrained a pplication p rotocol (c oap) the way coap interact is very similar to the http client/server model, but is common to use a node performing both client and server. a coap request is sent by a client to a server in order to request an action (specified with a method code parameter) on a particular resource identified by an uri. then the server returns a response containing a response code, with the resource or an error message. coap differs from http when dealing these messages exchanges because it handles them asynchronously over the transport layer (in this case the udp, in section vi we will see how coap works over tcp). 4 types of message are supported by coap: confirmable, non-confirmable, acknowledgement and reset. those messages can transport request  2  name  data size (eg. ram)  code size (eg. rom)  class 0, c0   10kb   100kb  class 1, c1  ∼10kb  ∼100kb  class 2, c2  ∼50kb  ∼250kb  functionality very constrained devices. cannot communicate with the internet directly. ip and security capable, cannot easily communicate using full ip stacks, such as http. may be able to use coap over udp. support most protocol stacks.  table 1: classification of constrained devices  fig. 5: example of get requests that receive piggybacked responses fig. 3: reliable message transmission the request. and when it’s ready to respond, it sends a confirmable message including the content that must be confirmed with an ack message from the client. this mechanism is called ”separate response” and can be seen in fig. 6.  seen in fig. 4. coap message types are summarized in table 2.  fig. 4: unreliable message transmission b. request/response model the top abstract layer of coap is the request/response layer. request and responses are carried by the coap messages, that includes a method code or a response code. a token is used to pair the response to the corresponding request. the request is sent by means of a confirmable (con) or a non-confirmable (non) message. if the request is sent through a confirmable message, the server replies with an acknowledgement (ack) message with the resource or with an error code, this is called piggybacked response. this process can be seen in fig. 5. if the server is not capable to reply rapidly to the confirmable message, it sends back and empty ack message, otherwise the client will continue to retransmit  fig. 6: a get request with a separate response  3  message type confirmable non-confirmable reset acknowledgment  description reliable message delivery, the recipient is required to confirm with an acknowledgment not acknowledged, delivery is not guaranteed indicates that a message was received, but the receiver is not capable to process/handle it indicates that the message was received and processed correctly table 2: coap message types  instead, if the request is sent by using a nonconfirmable message (non), the response is sent also as non-confirmable that you can see in fig. 7.  work on constrained networks, it implements compact messages and, to avoid the fragmentation, it uses the data section of just one udp datagram, but it can also be transported over tcp. a. message format the message format is composed by a 4-byte header, followed by a token value which length is stated in the tkl header field (0 to 8 bytes), as said before the role of this token is to match requests with responses. then a sequence of 0 or more options in the type-lengthvalue (tlv) format. an option might be followed by the end of the message, by some other option, or by the 0xf f (the payload marker) which express the end of the options section and the start of the payload which may take the rest of the datagram size. this format can be seen in fig. 9. in particular the header fields are defined as follow: • version (ver): 2-bit unsigned integer. • type (t): 2-bit unsigned integer. 0=confirmable, 1=non-confirmable, 2=acknowledgement, or 3=reset • token length (tkl): 4-bit unsigned integer. represents the length of the variable-length token field which size can be between 0 and 8 bytes. lengths 9-15 must be reserved, and not sent, and are processed as a message format error. • code: 8-bit unsigned integer, divided into a 3-bit class (most significant bits) and a 5-bit detail (least significant bits). class are 0=request, 2=success response, 4=client error response, or 5=server error response. for example 0.00=empty message. in the case of a request, this field express the request method; in case of a response, a response code. • message id: 16-bit unsigned integer in network byte order. the option format requires to each option instance to specify its option number, its value field length and the option value itself. more than one instance of the same option can be set by specifying an option delta of zero. we don’t go further on this concept because its  fig. 7: request and response sent by non-confirmable messages c. intermediaries, caching and resource discovery to fulfill request efficiently coap offer the caching of responses. since we are working on constrained networks, coap also offer the possibility of creating a proxy, this is due to restrain network traffic, boost performances, to access to the data of devices in sleep mode, and to provide security. like in http proxying, the ip address of destination is the address of the proxy while the resource’s uri is inside the request. there is also the possibility to map coap to http and the other way around. this conversion can be realized by a cross-proxy (a cross-protocol proxy) that converts method/response codes, options o the corresponding in http. as final note of this section, since in the context of m2m interactions resource discovery is pretty important, coap support it using the core link format. iv. m essage f ormat, t ransmission and s emantic in this section we are going to cover the coap message format. since this protocol was created to  4  the timeout is reached and the retransmission counter is less than max_retransmit (default is 4), the message is sent again, the counter for retransmission is incremented, and the timeout is doubled. this continues until the counter reach max_retransmit or the sender receive a rst message. messages transmitted without reliability: usually this are messages that are sent regularly, like data from a sensor where the eventual success is enough. those kinds of messages can be sent marking the proper header field as non-confirmable (non) message. this kind of messages must not be empty.  quite complicated and long, we limit ourselves to show the structure in fig. 8, for further information, read the rfc7252 [2].  c. message semantic coap uses an analogous request/response model of http, basically a client might sends several coap requests to a server, which sends back coap responses. but, unlike http, those request and responses are not sent after a pre-established connection, there are sent asynchronously. requests: consist of a method to be applied to a specific resource, the resource identifier, the payload and the internet media type (if any), and the request’s metadata (optional). the methods supported by coap are get, post, put, and delete. they are safe (only on retrieval) and idempotent (when invoked multiple times have the same effect) like for the equivalent http. responses: they are matched with the request by a token generated by the client. they can be identified using the code field in the header. like for the http status code the coap response code express the result of trying to satisfy the client request. the (8-bit) response code (fig. 10) define the class (3-bit) and the detail (5-bit) of the response. there are 3 main classes of response code: • 2 (success): indicates that the request has been successfully received, understood and accepted. • 4 (client error): the request cannot be fulfilled or contains syntax that the server is not able to understand. • 5 (server error): the request is valid but the server is not able to fulfill it.  fig. 8: coap message option format b. message transmission coap messages are used to transport request and responses between coap endpoints, and they are exchange asynchronously. since udp is not reliable transport protocol, those messages may not arrive in order, they can be missing or can be duplicated. so, coap uses a small mechanism to assure reliability that can detect duplicates for both confirmable (con) and nonconfirmable (non) messages, and implements for confirmable messages a basic reliability system based on stop-and-wait retransmission with exponential back-off. messages and endpoints: an endpoint,identified by an ip address plus an udp port number, is the source or destination of a coap message. as we said, there are various types of messages, that can carry a request, a response or are empty. if a message is empty, it’s code field is set to 0.00, the token length field (tkl) to 0 and id there are bytes present in the payload, they are interpreted as error message. messages transmitted reliably: to transimt with reliability the message has to be marked as confirmable (con) in the proper header field. this kind of message always carries a request, a response or a reset, so a receiver must return an ack or reject it. the rejection of a confirmable message contains the message id and the payload is empty. the sender keeps retransmitting the message at increasing intervals until it receives an ack, a rst or reach the limit of attempts. at start, the timeout is initialized to a random duration between ack_timeout (default is 2 seconds) and (ack_timeout * ack_random_factor (default is 1.5)), and the retransmission counter starts from 0. when  v. c oap m ethods , c aching and p roxying a. method definitions resources are organized with a hierarchy and directed by a coap origin server that listen for coap requests (”coap” or ”coaps”). coap uri scheme is defined as follows: coap-uri = ”coap:” ”//” host [ ”:” port ] pathabempty [ ”?” query ]  5  fig. 9: coap message format  some other iot frameworks uses the use of crud methods (create, retrieve, update, delete) to overcome this ambiguity. a brief summary of coap methods can also be seen in table 3.  fig. 10: response code structure where host must not be empty and port indicates the udp port, if it’s empty the default 5683 is used. coap implements methods, very similar to http, with which clients can call an action on a specific resource identified the previously mentioned uris. a request with a method that is not supported, returns a 4.05 (method not allowed) response. the methods supported by coap are: •  •  •  •  b. caching we just briefly note that coap endpoints have the possibility to cache the responses in order to reduce the time of response and bandwidth usage. the main purpose of coap caching is to reuse a response message to fulfill a current request that is the same of a past one. the cacheability of a response depends on the response code.  get: retrieves the representation of the resource identified by the uri. if this is possible, the server returns a 2.03 (valid) or 2.05 (content) response code. this method is safe (it must not take other action on a resource other than retrieval) and idempotent. post: results in a creation, update or deletion of a resource. if a resource is created, the server returns s 2.01 (created) response code with the uri. if there is an update of the resource, the server returns a 2.04 (changed) response code. instead, if a resource is deleted, the server returns a 2.02 (deleted) response code. post is not safe and not idempotent. is not idempotent because its effect is established by the origin server and dependent on the target resource. put: result in the creation or update of the resource specified by the uri given. its response codes are the same of post. put is idempotent but not safe. delete: results in the deletion of the resource identified by the uri given. if succeed, a 2.02 (deleted) response code is returned. delete is idempotent but not safe.  c. proxying proxies can serve many different purposes; we can distinguish them in 3 main types: • forward-proxies: coap request on such proxies can be made as confirmable (con) or nonconfirmable (non), but the request uri is specified in the proxy-uri option instead of being split in uri-host, uri-port, uri-path and uri-query options. if the endpoint is not able to act as a proxy, it returns a 5.05 (proxying not supported) response. • reverse-proxies: offer various resources as if they were its own resources. • cross-proxies: can translate a coap request/response to a different protocol. more specifically, a particular kind of cross-proxying is of interest in iot when using coap, that is the crossprotocol proxying between coap and http, that’s because coap support a limited subset of http functionalities. only the request/response model of coap is mapped to http. the confirmable/non-confirmable messages model is invisible and has no effect on a proxy function. coap-http proxying: enables coap clients to access resources that are hosted on a http server. when  the difference between post and put is that put in generally used to replace the existing content of a resource, while post is used to send new data.  6  methods get put post delete  description retrieves a representation of information corresponding to the specified uri requests to update the identified resource be updated with the enclosed representation, or create new request to process the enclosed representation delete the resource identified by the uri table 3: coap methods  sending a request to the coap-http proxy, a coap client has to set the proxy-uri or proxy-scheme option to ”http” or ”https”. since the basic methods of coap are very similar to http, performing a request is not much different. if the proxy is not able to service the request with the http uri, it returns a 5.05 (proxying not supported) response. if the proxy is unable to get the requested resource by the http server in a given timeframe, it returns a 5.04 (gateway timeout) response. if the resource is not understood, it returns a 5.02 (bad gateway) response. the response payload must be a representation of the http resource, and the contentformat option should be set accordingly. http-coap proxying: enables http clients to access resources hosted on coap servers. when sending a request to the http-coap proxy, an http client has to set the request-line to ”coap” or ”coaps”. if the proxy is not able to service the request with the coap uri, it returns a 501 (not implemented) response. if the proxy is not able to get the requested resource by the coap server in a given timeframe, it returns a 504 (gateway timeout) response. if the resource is not understood, it returns a 502 (bad gateway) response. since the methods option, trace and connect are not implemented in coap, if those one are called, the proxy returns a 501 (not implemented) error.  sophisticated that the one of coap over udp, but uses a larger packet size, more round trips, and increased ram requirements. the main difference between coap over tcp and over udp is on the message layer, while the request/response model remains the same. messaging model: since tcp provides reliable transmission, coap confirmable and acknowledge message are no longer needed. so, the type field and message id field in the header are not present anymore, instead the fields for expressing the length of the message (length and extended length) are present because tcp does not provide this information. message format: is very similar of the one over udp, except for type, message id and version fields that are removed as previously said. this format can be seen in fig. 11. message transmission: after the tcp connection is established, the coap endpoints send a csm (capabilities and settings message) as first message of the connection. this special message initializes the settings and capabilities of the endpoints, if there are no options set in this message, the defaults are used. request and response are sent asynchronously over the transport connection. so, a client can send multiple requests without waiting for responses, and those responses can be returned in any order but in the same connection. the tcp protocol is bidirectional, this implies that requests and responses can be sent by both endpoints. tcp also support retransmission and deduplication of messages.  vi. c oap enhancements in this section we are going to review some enhancements and extensions of the standard coap protocol. in particular we explore the coap over tcp and coap for streaming.  b. coap for streaming in the last years, a variety of streaming application in iot are becoming more common, in this paper the authors explore the usage of the coap protocol for this task. the conventional coap over udp and coap over tcp schemes can be used for reliable services as we seen. however, they do not provide error handling and flow controls suitable to facilitate the streaming data transmission at the sender, this leads to a degradation of the throughput performances, especially in sensor wireless lossy networks. for example, if in coap over udp a message gets lost, its retransmission will happen  a. coap over tcp the standard coap operates above the user datagram protocol (udp) accomplishing lightweight messaging. but the main downsides are that udp cannot provide reliability and some networks, especially enterprise networks, do not froward udp packets. for those reasons and that the demand for the use of tcp in iot is increasing, coap over tcp was proposed [3]. tcp has congestion control and flow control mechanism, more  7  fig. 11: coap over tcp message format  after a timeout, making the error recovery to increase transmission delays. in coap over tcp the packet can be recovered quickly using the tcp fast recovery, but this mechanism adds overhead in the iot environment. moreover, the complexity of tcp is not very suitable for real time streaming in iot environment. to overcome these problems, the authors [4] proposed a coap-based streaming control (coap-sc), which is an extension of coap over udp with error handling and flow controls for throughput enhancement. the scheme is designed by assigning a sequence number (sn) to each data message, and an ack number (an) is returned by the receiver. initialization for coap-sc: with a post message the sender requests the creation of a new resource, this request include authentication information, buffer size and other parameters associated with the streaming service. after the creation of the resource, the receiver returns a 2.01 response message with the url of this new resource. then, the sender sends a get request to that url, and the receiver responds back with a 2.05 response message. all get and their response messages contains a sequence number (sn) and ack number (an), where sn is sequentially assigned on each message sent by the sender, and the an is set by the receiver to tell that that message was received correctly. the an is cumulative. in the initialization process sn and an are set to 0. this initialization process can be seen in fig 12. error handling for coap-sc: the first message sent by the sender has sn=1 and an=0. each time the receiver gets a message from the sender, it updates its own an number to be equal to the largest sn value that has been received and cumulatively. so, if the receiver does not receive any data message for a certain amount of time, it sends an ack message to tell the sender of the an status. in the normal streaming flow, the receiver will receive a message with sn = ansent + 1, and the next message it will send, will have an = snreceived = ansent + 1. so, if a message gets lost, the receiver will determine that by checking if this  fig. 12: coap-sc initialization condition is true: snreceived − ansent > 1. when this loss is detected, the receiver sends an ack message for a retransmission request that includes the sn of the message to be transmitted, and this ack is retransmitted until the data lost is correctly received. an example of this mechanism can be seen in fig. 13. flow control for coap-sc: ack messages are used also for flow control, by providing the up-to-date an information to the sender, in this way facilitating it to transmit as much data as possible, resulting a throughput enhancement. coap option for coap-sc: the option header is composed by 4bit option delta, 4-bit option length, 4-byte sequence number and 4-byte ack number. this  8  fig. 14: coap-sc message option format from the most recent literature. in particular for reliability, a rfc called ”coap over tcp” that as its title says, modifies coap to work on the reliable transport protocol tcp. while for the streaming scenario, a modification called coap-sc was reviewed, that propose good a mechanism to deal with errors and flow control that are crucial in streaming. on the other hand, it seems that this streaming scheme still requires some more works to reduce the packet size for iot environment. viii. acknowledgment this work is presented for the final grade of the ”internet of things and smart cities” course, held by prof. lorenzo vangelista at the university of padova in 2021. r eferences [1] m. belshe, r. peon, and m. thomson, “hypertext transfer protocol version 2 (http/2).” rfc 7540, may 2015. [2] z. shelby, k. hartke, and c. bormann, “the constrained application protocol (coap).” rfc 7252, june 2014. [3] c. bormann, s. lemay, h. tschofenig, k. hartke, b. silverajan, and b. raymor, “coap (constrained application protocol) over tcp, tls, and websockets.” rfc 8323, feb. 2018. [4] j.-h. jung, m. gohar, and s.-j. koh, “coap-based streaming control for iot applications,” electronics, vol. 9, no. 8, 2020.  fig. 13: coap-sc error handling example option format can be seen in fig. 14. vii. c oncluding r emarks in this paper an overview of the coap protocol has given. since the basic architecture of coap may perform inefficiently in some scenarios like when strong reliability is needed and in the case of streaming applications, we proposed possible solutions for those problems taken  9  