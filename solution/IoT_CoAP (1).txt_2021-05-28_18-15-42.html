an overview <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> protocol </span> architecture, features and its extensions stefano ivancich department of information engineering (dei) university of padova, italy email: stefano.ivancich@studenti.unipd.it student id: 1227846  which rules the communication between web clients and web servers. it’s used mostly for transfer html documents between nodes. at its basis it is a textual requestresponse protocol where clients and servers exchange messages constituted by an header and an optional body. is a stateless protocol, that basically means that each request-response is independent and neither the client nor the server has to keep trace of the exchanged messages. this simplifies the implementation of the protocol and makes it more scalable. and is designed to favors the use of intermediaries or proxies, typically for caching or security purposes. it is appropriate for devices with relatively high computational power, but often it can be too demanding in terms of bandwidth and processing requirements for the constrained devices that we are considering in the iot scenario. so, a protocol called <span style="color: red"> constrained </span> <span style="color: red"> application </span> <span style="color: red"> protocol </span> <span style="color: red"> (coap) </span> defined in the rfc 7252 [2] was developed as a lightweight counterpart of http in order to simplify <span style="color: red"> integration </span> <span style="color: red"> with </span> <span style="color: red"> the </span> <span style="color: red"> web </span> but <span style="color: red"> at </span> <span style="color: red"> the </span> <span style="color: red"> same </span> <span style="color: red"> time </span> address the needs of constrained devices and constrained networks, indeed those kind of nodes usually carry 8-bit microcontrollers with very small amounts of rom/ram, while constrained networks generally suffer of <span style="color: red"> high </span> <span style="color: red"> packet </span> <span style="color: red"> error </span> <span style="color: red"> rates </span> <span style="color: red"> and </span> have an indicative throughput of 10s kbit/s. <span style="color: red"> this </span> <span style="color: red"> protocol </span> <span style="color: red"> is </span> <span style="color: red"> used </span> for machine-to-machine (m2m) communication and, as said before, <span style="color: red"> is </span> <span style="color: red"> quite </span> <span style="color: red"> similar </span> <span style="color: red"> to </span> http, but with some relevant differences. it uses smaller and simplified headers, supports asynchronous rest, publish/subscribe message exchanges, provides support for multicast, extremely low overhead, and is easy to implement for constrained environments. the aim <span style="color: red"> of </span> <span style="color: red"> coap </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> to </span> indiscriminately compress the http protocol, but instead to provide a subgroup of rest in common with http that are optimized for m2m communications. in this work, we focus on the iot communication pro-  fig. 1: stefano ivancich in 2021 abstract—today (2021), several billions of devices are connected daily to the internet, so a very huge amount of a data is sent and managed every second. in the next years, it is expected that even more devices like sensors, actuators for domestic or industrial usage will connect to the internet. in this context, we review an http like protocol called <span style="color: red"> constrained </span> <span style="color: red"> application </span> <span style="color: red"> protocol </span> <span style="color: red"> (coap) </span> that was developed by the internet of engineering task (ietf) to work on constrained iot devices operating in lossy environments. although this protocol is lightweight and efficient compared to other iot protocols such as http or mqtt, <span style="color: red"> it </span> <span style="color: red"> has </span> <span style="color: red"> some </span> <span style="color: red"> limitation </span> in some scenarios, for example when strong reliability is needed or in streaming applications. for this reason we also overview, from the most recent literature some modifications, one is coap over tcp that guarantee reliability, another is coap-sc that has a good mechanism to handle with <span style="color: red"> error </span> <span style="color: red"> and </span> <span style="color: red"> flow </span> <span style="color: red"> control </span> that are crucial in streaming applications. index terms—coap, iot, tcp, udp, streaming, enhancements in coap  i. i ntroduction the hypertext transfer protocol (http) [1] <span style="color: red"> is </span> <span style="color: red"> one </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> most </span> widely used application layer protocol for distributed, collaborative, hypermedia information systems,  1  messages can transport request or responses based on their method codes or response codes. both request <span style="color: red"> and </span> <span style="color: red"> responses </span> <span style="color: red"> can </span> <span style="color: red"> be </span> confirmable or non-confirmable. we can think of coap as a two-layer protocol, one layer for messaging that deal with the transport layer and with asynchronous messages, and a request/response layer that manages request/response interactions through method and response codes. you can see this in fig. 2.  tocol coap; in particular, we overview its architecture, features and extensions. the report is structured as follows: in section ii we describe the communication problems in constrained networks, in section iii we give an overview <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> protocol </span> that tackle those problems, and in section iv we describe it’s message format, it’s transmission and semantic. in section v we describe the coap methods definitions, caching and proxying. in section vi we review some extension and modifications of the standard coap protocol. and finally in section vii we make some extra considerations on future developments and possible improvements. ii. c onstrained d evices and n etworks edge networks may operate in a huge variety of environments and conditions that requires a careful attention on their use. usually, data flowing throw edge networks are ultimately destined for the internet, so they should be designed with that transition in mind and therefore it makes some sense to emulate some ideas in iot edge network design. the so-called constrained networks are characterized as low-power and lossy networks (llns). those kinds of networks are used often in combination with constrained devices that, have limited processing and powers supply, in table 1 you can see a classification of constrained devices. llns are constrained because the cost, the limited nodes capabilities, limited power, limited spectrum, high density and interference. so they need smaller (compressed) headers and smaller payloads/packets to keep bit error rates low and permit media sharing. that’s where lightweight communication protocols like coap comes into play.  fig. 2: <span style="color: red"> abstract </span> <span style="color: red"> layering </span> <span style="color: red"> of </span> <span style="color: red"> coap </span> now <span style="color: red"> we </span> <span style="color: red"> are </span> <span style="color: red"> going </span> <span style="color: red"> to </span> explain these 2 layers in depth. a. messaging model the message layer is the bottom layer of coap and it deals with <span style="color: red"> the </span> <span style="color: red"> exchange </span> <span style="color: red"> of </span> <span style="color: red"> messages </span> <span style="color: red"> over </span> the transport layer, in the base case the udp datagrams, but in the following section we will see how it adapts to tcp. coap uses a binary header of fixed length (4 bytes), after which a <span style="color: red"> compact </span> <span style="color: red"> binary </span> <span style="color: red"> options </span> <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> payload </span> might follow. every message in coap has a 16-bit unique id <span style="color: red"> used </span> <span style="color: red"> for </span> <span style="color: red"> the </span> <span style="color: red"> detection </span> <span style="color: red"> of </span> duplicates and for reliability, allowing an exchange of up to 250 messages per second. <span style="color: red"> a </span> <span style="color: red"> message </span> <span style="color: red"> can </span> <span style="color: red"> be </span> sent reliably if its type is confirmable (con), a response will be provided with the acknowledgement message (ack) type carrying <span style="color: red"> the </span> <span style="color: red"> same </span> <span style="color: red"> message </span> <span style="color: red"> id </span> or with the reset message (rst) if the recipient is not capable to handle/process the message that was sent. this process <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 3. a non-reliable message <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> sent </span> <span style="color: red"> as </span> nonconfirmable message (non) that won’t have any acknowledge response, but if the recipient has some troubles processing such message, it can reply with the reset message (rst). even though these kind <span style="color: red"> of </span> <span style="color: red"> messages </span> <span style="color: red"> are </span> <span style="color: red">  </span> iii. c onstrained a pplication p rotocol (c oap) the way coap interact <span style="color: red"> is </span> <span style="color: red"> very </span> <span style="color: red"> similar </span> <span style="color: red"> to </span> <span style="color: red"> the </span> <span style="color: red"> http </span> client/server model, but is common to use a node performing both client and server. <span style="color: red"> a </span> <span style="color: red"> coap </span> <span style="color: red"> request </span> <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> by </span> <span style="color: red"> a </span> <span style="color: red"> client </span> <span style="color: red"> to </span> <span style="color: red"> a </span> server <span style="color: red"> in </span> <span style="color: red"> order </span> <span style="color: red"> to </span> <span style="color: red"> request </span> <span style="color: red"> an </span> <span style="color: red"> action </span> (specified with a method code parameter) on a particular resource identified by an uri. then the server returns a response containing a response code, with the resource or an error message. coap differs from http when dealing with those messages exchanges because it handles them asynchronously over the transport layer (in this case the udp, in section vi we will describe how coap can also work over tcp). 4 types of message are supported by coap: confirmable, non-confirmable, acknowledgement and reset. those  2  name  data size (eg. ram)  code size (eg. rom)  class 0, c0   10kb   100kb  class 1, c1  ∼10kb  ∼100kb  class 2, c2  ∼50kb  ∼250kb  functionality very constrained devices. cannot communicate with the internet directly. ip and security capable, cannot easily communicate using full ip stacks, such as http. <span style="color: red"> may </span> <span style="color: red"> be </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> use </span> <span style="color: red"> coap </span> <span style="color: red"> over </span> udp. support most protocol stacks.  table 1: classification of constrained devices  fig. 5: example of get requests that receive piggybacked responses fig. 3: reliable message transmission message, otherwise the client will continue to retransmit the request. and when it’s ready to respond, it sends a confirmable message including the content that must be confirmed with an ack message from the client. this mechanism is called ”separate response” and <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 6. instead, <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> is </span> <span style="color: red"> sent </span> by using a nonconfirmable message (non), the response is sent also as non-confirmable that you can see in fig. 7.  not reliable, they carry a unique id. this process <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 4. coap message types <span style="color: red"> are </span> <span style="color: red"> summarized </span> <span style="color: red"> in </span> <span style="color: red"> table </span> 2.  c. intermediaries, caching and resource discovery  fig. 4: unreliable message transmission  to fulfill request efficiently coap offer the caching of responses. since we are working on constrained networks, coap also offer the possibility of creating a proxy, <span style="color: red"> this </span> <span style="color: red"> is </span> <span style="color: red"> due </span> <span style="color: red"> to </span> restrain network traffic, boost performances, to access to the data of devices in sleep mode, and to provide security. like in http proxying, the destination ip is the proxy address while the resource’s uri is inside the request. there is also the possibility to map <span style="color: red"> coap </span> <span style="color: red"> to </span> <span style="color: red"> http </span> <span style="color: red"> and </span> the other way around. <span style="color: red"> this </span> <span style="color: red"> conversion </span> <span style="color: red"> can </span> <span style="color: red"> be </span> realized by a cross-proxy (a crossprotocol proxy) that converts method/response codes, options o the corresponding in http. as final note of this section, since <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> context </span> <span style="color: red"> of </span> m2m interactions resource discovery is pretty important, coap support it <span style="color: red"> using </span> <span style="color: red"> the </span> <span style="color: red"> core </span> <span style="color: red"> link </span> <span style="color: red"> format </span> [3].  b. request/response model the top abstract layer of coap is the request/response layer. request and responses are carried by the coap messages, that includes <span style="color: red"> a </span> <span style="color: red"> method </span> <span style="color: red"> code </span> <span style="color: red"> or </span> a response code. a <span style="color: red"> token </span> <span style="color: red"> is </span> <span style="color: red"> used </span> <span style="color: red"> to </span> pair <span style="color: red"> the </span> <span style="color: red"> response </span> <span style="color: red"> to </span> <span style="color: red"> the </span> corresponding request. <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> by </span> <span style="color: red"> means </span> <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> confirmable </span> <span style="color: red"> (con) </span> <span style="color: red"> or </span> a non-confirmable (non) message. <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> is </span> <span style="color: red"> sent </span> through a confirmable message, the server replies with an acknowledgement (ack) message with the resource or with an error code, this process is called piggybacked response and <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 5. <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> server </span> <span style="color: red"> is </span> <span style="color: red"> not </span> capable to reply rapidly to the confirmable message, it sends back and empty ack  3  message type confirmable non-confirmable reset acknowledgment  description reliable message delivery, the recipient is required to confirm with an acknowledgment not acknowledged, delivery is not guaranteed indicates that a message was received, but <span style="color: red"> the </span> <span style="color: red"> receiver </span> <span style="color: red"> is </span> <span style="color: red"> not </span> capable to process/handle it indicates that the message was received and processed correctly table 2: coap message types  fig. 7: request and response sent by non-confirmable messages remaining datagram size. this format <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 9. in particular the header fields are defined as follow: • version (ver): 2-bit unsigned integer. • type (t): 2-bit unsigned integer. 0=confirmable, 1=non-confirmable, 2=acknowledgement, or 3=reset • token length (tkl): 4-bit unsigned integer. represents <span style="color: red"> the </span> <span style="color: red"> length </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> variable-length </span> <span style="color: red"> token </span> <span style="color: red"> field </span> which size <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> between </span> <span style="color: red"> 0 </span> <span style="color: red"> and </span> <span style="color: red"> 8 </span> bytes. lengths 9-15 must be reserved, not sent, and are interpreted <span style="color: red"> as </span> <span style="color: red"> a </span> <span style="color: red"> message </span> <span style="color: red"> format </span> <span style="color: red"> error. </span> • code: 8-bit unsigned integer, divided <span style="color: red"> into </span> <span style="color: red"> a </span> <span style="color: red"> 3-bit </span> <span style="color: red"> class </span> <span style="color: red"> (most </span> <span style="color: red"> significant </span> <span style="color: red"> bits) </span> <span style="color: red"> and </span> <span style="color: red"> a </span> <span style="color: red"> 5-bit </span> <span style="color: red"> detail </span> <span style="color: red"> (least </span> <span style="color: red"> significant </span> <span style="color: red"> bits). </span> class are 0=request, 2=success response, 4=client error response, or 5=server error response. for example 0.00=empty message. <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> case </span> <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> request, </span> this field express the request method; while <span style="color: red"> in </span> <span style="color: red"> case </span> <span style="color: red"> of </span> <span style="color: red"> a </span> response, it express a response code. • message id: <span style="color: red"> 16-bit </span> <span style="color: red"> unsigned </span> <span style="color: red"> integer </span> <span style="color: red"> in </span> <span style="color: red"> network </span> <span style="color: red"> byte </span> <span style="color: red"> order. </span> the option format requires to each option instance to specify its option number, its value field length and the option value itself. more than one instance <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> same </span> <span style="color: red"> option </span> <span style="color: red"> can </span> <span style="color: red"> be </span> set by specifying <span style="color: red"> an </span> <span style="color: red"> option </span> <span style="color: red"> delta </span> <span style="color: red"> of </span> <span style="color: red"> zero. </span> we don’t go further on this concept because its  fig. 6: <span style="color: red"> a </span> <span style="color: red"> get </span> <span style="color: red"> request </span> <span style="color: red"> with </span> <span style="color: red"> a </span> <span style="color: red"> separate </span> <span style="color: red"> response </span> iv. m essage f ormat, t ransmission and s emantic in this section <span style="color: red"> we </span> <span style="color: red"> are </span> <span style="color: red"> going </span> <span style="color: red"> to </span> cover <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> message </span> <span style="color: red"> format. </span> since this protocol was created to work on constrained networks, it implements compact messages and, to avoid the fragmentation, it uses <span style="color: red"> the </span> <span style="color: red"> data </span> <span style="color: red"> section </span> <span style="color: red"> of </span> just one udp datagram, but it can also be transported over tcp. a. message format the message format is composed by a 4-byte header, followed by a token value which length is stated in the tkl header field (0 to 8 bytes), as said before the role of this token is to match requests with responses. then <span style="color: red"> a </span> <span style="color: red"> sequence </span> <span style="color: red"> of </span> <span style="color: red"> 0 </span> or more options in the type-length-value (tlv) format. an option might be followed by other options, <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> end </span> <span style="color: red"> of </span> message, or by the 0xf f (the payload marker) which express <span style="color: red"> the </span> <span style="color: red"> end </span> <span style="color: red"> of </span> <span style="color: red"> the </span> options section <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> start </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> payload </span> which may take the  4  1.5)), <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> retransmission </span> <span style="color: red"> counter </span> starts from <span style="color: red"> 0. </span> <span style="color: red"> when </span> <span style="color: red"> the </span> <span style="color: red"> timeout </span> <span style="color: red"> is </span> reached <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> retransmission </span> <span style="color: red"> counter </span> <span style="color: red"> is </span> <span style="color: red"> less </span> <span style="color: red"> than </span> <span style="color: red"> max_retransmit </span> (default is 4), the message is sent again, the counter for retransmission <span style="color: red"> is </span> <span style="color: red"> incremented, </span> <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> timeout </span> <span style="color: red"> is </span> <span style="color: red"> doubled. </span> this continues until the counter reach max_retransmit or the sender receive a rst message. messages transmitted without reliability: usually this are messages that are sent regularly, like data coming <span style="color: red"> from </span> <span style="color: red"> a </span> <span style="color: red"> sensor </span> <span style="color: red"> where </span> the eventual transmission success is enough. those kinds of messages can be sent marking the proper header field as non-confirmable (non) message. this kind of messages <span style="color: red"> must </span> <span style="color: red"> not </span> <span style="color: red"> be </span> <span style="color: red"> empty. </span> <span style="color: red">  </span> quite complicated and long, we limit ourselves to show the structure in fig. 8, for further information, read the rfc7252 [2].  c. message semantic coap uses an analogous request/response model of http, basically a client might sends several <span style="color: red"> coap </span> <span style="color: red"> requests </span> <span style="color: red"> to </span> <span style="color: red"> a </span> server, which sends back coap responses. but, unlike http, those request <span style="color: red"> and </span> <span style="color: red"> responses </span> <span style="color: red"> are </span> <span style="color: red"> not </span> <span style="color: red"> sent </span> after a pre-established connection, there are sent asynchronously. requests: consist of a <span style="color: red"> method </span> <span style="color: red"> to </span> <span style="color: red"> be </span> <span style="color: red"> applied </span> <span style="color: red"> to </span> a specific resource, the resource identifier, the payload and <span style="color: red"> the </span> <span style="color: red"> internet </span> <span style="color: red"> media </span> <span style="color: red"> type </span> <span style="color: red"> (if </span> <span style="color: red"> any), </span> <span style="color: red"> and </span> the request’s metadata (optional). the methods supported by coap are <span style="color: red"> get, </span> <span style="color: red"> post, </span> <span style="color: red"> put, </span> <span style="color: red"> and </span> delete. they are safe (only on retrieval) and idempotent (when invoked multiple times have the same effect) like for the equivalent http. responses: they are matched with the request by a token generated by the client. they can be identified using <span style="color: red"> the </span> <span style="color: red"> code </span> <span style="color: red"> field </span> <span style="color: red"> in </span> <span style="color: red"> the </span> header. like for <span style="color: red"> the </span> <span style="color: red"> http </span> <span style="color: red"> status </span> <span style="color: red"> code, </span> <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> same </span> <span style="color: red"> way </span> <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> response </span> <span style="color: red"> code </span> express the result of trying to satisfy the client request. the (8-bit) response code (fig. 10) define the class (3bit) and the detail (5-bit) of the response. there are 3 main classes of response code: • 2 (success): indicates that the request has been successfully received, understood and accepted. • 4 (client error): the request cannot be fulfilled or contains syntax <span style="color: red"> that </span> <span style="color: red"> the </span> <span style="color: red"> server </span> <span style="color: red"> is </span> <span style="color: red"> not </span> capable to understand. • 5 (server error): the request is valid but <span style="color: red"> the </span> <span style="color: red"> server </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> fulfill it.  fig. 8: coap message option format b. message transmission coap messages are used to carry request and responses between coap endpoints, and they are exchanged asynchronously. since udp is not a reliable transport protocol, those messages may not arrive in order, they can be missing or can be duplicated. so, coap uses a small mechanism to assure reliability that can detect duplicates for both confirmable (con) and nonconfirmable (non) messages, in particular, implements for confirmable messages a basic reliability system based on stop-and-wait retransmission with exponential back-off. messages and endpoints: an endpoint, identified by an ip address plus an udp port number, is the destination or <span style="color: red"> the </span> <span style="color: red"> source </span> <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> coap </span> <span style="color: red"> message. </span> as we said, there are various types of messages, that can transport <span style="color: red"> a </span> <span style="color: red"> request, </span> <span style="color: red"> a </span> <span style="color: red"> response </span> or are empty. <span style="color: red"> if </span> <span style="color: red"> a </span> <span style="color: red"> message </span> <span style="color: red"> is </span> empty, it’s code <span style="color: red"> field </span> <span style="color: red"> is </span> <span style="color: red"> set </span> <span style="color: red"> to </span> 0.00, <span style="color: red"> the </span> <span style="color: red"> token </span> <span style="color: red"> length </span> <span style="color: red"> field </span> (tkl) to 0 and if there are bytes present in the payload, they are interpreted as error message. messages transmitted reliably: to transimt with reliability the message has to be marked as confirmable (con) in the proper header field. <span style="color: red"> this </span> <span style="color: red"> type </span> <span style="color: red"> of </span> <span style="color: red"> message </span> always carries <span style="color: red"> a </span> <span style="color: red"> request, </span> <span style="color: red"> a </span> <span style="color: red"> response </span> or a reset, so a receiver must return an ack or reject it. the rejection <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> confirmable </span> <span style="color: red"> message </span> contains <span style="color: red"> the </span> <span style="color: red"> message </span> <span style="color: red"> id </span> <span style="color: red"> and </span> the payload is empty. the sender keeps retransmitting the message at increasing intervals <span style="color: red"> until </span> <span style="color: red"> it </span> <span style="color: red"> receives </span> <span style="color: red"> an </span> ack, a rst or reach the limit of attempts. at start, the timeout is initialized <span style="color: red"> to </span> <span style="color: red"> a </span> <span style="color: red"> random </span> <span style="color: red"> duration </span> between ack_timeout (default is 2 seconds) <span style="color: red"> and </span> <span style="color: red"> (ack_timeout </span> <span style="color: red"> * </span> <span style="color: red"> ack_random_factor </span> (default is  v. c oap m ethods , c aching and p roxying a. method definitions resources are organized with a hierarchy and directed by <span style="color: red"> a </span> <span style="color: red"> coap </span> <span style="color: red"> origin </span> <span style="color: red"> server </span> that listen for coap requests (”coap” or ”coaps”). coap uri scheme <span style="color: red"> is </span> <span style="color: red"> defined </span> <span style="color: red"> as </span> <span style="color: red">  </span> 5  fig. 9: <span style="color: red"> coap </span> <span style="color: red"> message </span> <span style="color: red"> format </span> <span style="color: red">  </span> is generally used to replace the existing content of a resource, while post is used to send new data. some other iot frameworks uses the use of crud methods (create, retrieve, update, delete) to overcome this ambiguity. a brief summary of coap methods can also be seen in table 3.  fig. 10: response code structure follows: coap-uri = ”coap:” ”//” host [ ”:” port ] pathabempty [ ”?” query ] where <span style="color: red"> host </span> <span style="color: red"> must </span> <span style="color: red"> not </span> <span style="color: red"> be </span> <span style="color: red"> empty </span> and port indicates the udp port, if it’s empty the default 5683 is used. coap implements methods, <span style="color: red"> very </span> <span style="color: red"> similar </span> <span style="color: red"> to </span> <span style="color: red"> http, </span> with which clients can call an action on a specific resource identified the previously mentioned uris. <span style="color: red"> a </span> <span style="color: red"> request </span> <span style="color: red"> with </span> <span style="color: red"> a </span> method that is not supported, returns the <span style="color: red"> 4.05 </span> <span style="color: red"> (method </span> <span style="color: red"> not </span> <span style="color: red"> allowed) </span> <span style="color: red"> response. </span> the methods supported by coap are: •  •  •  •  b. caching we just briefly note that coap endpoints have the possibility to cache the <span style="color: red"> responses </span> <span style="color: red"> in </span> <span style="color: red"> order </span> <span style="color: red"> to </span> <span style="color: red"> reduce </span> <span style="color: red"> the </span> time of response and bandwidth usage. the main purpose of coap caching <span style="color: red"> is </span> <span style="color: red"> to </span> <span style="color: red"> reuse </span> <span style="color: red"> a </span> response message to fulfill a current request that is the same of a past one. the cacheability of a response <span style="color: red"> depends </span> <span style="color: red"> on </span> <span style="color: red"> the </span> <span style="color: red"> response </span> <span style="color: red"> code. </span> <span style="color: red">  </span> get: <span style="color: red"> retrieves </span> <span style="color: red"> a </span> <span style="color: red"> representation </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> resource </span> that <span style="color: red"> is </span> <span style="color: red"> identified </span> <span style="color: red"> by </span> <span style="color: red"> the </span> uri. if this is possible, the server returns a 2.03 (valid) or 2.05 (content) response code. this method is safe (it must not take <span style="color: red"> other </span> <span style="color: red"> action </span> <span style="color: red"> on </span> <span style="color: red"> a </span> <span style="color: red"> resource </span> <span style="color: red"> other </span> <span style="color: red"> than </span> retrieval) and idempotent. post: results in a creation, update or deletion of a resource. if a resource is created, the server returns s <span style="color: red"> 2.01 </span> <span style="color: red"> (created) </span> <span style="color: red"> response </span> <span style="color: red"> code </span> with the uri. if there is an update of the resource, the server returns <span style="color: red"> a </span> <span style="color: red"> 2.04 </span> <span style="color: red"> (changed) </span> <span style="color: red"> response </span> <span style="color: red"> code. </span> instead, if a resource is deleted, the server returns <span style="color: red"> a </span> <span style="color: red"> 2.02 </span> <span style="color: red"> (deleted) </span> <span style="color: red"> response </span> <span style="color: red"> code. </span> post is not safe and not idempotent. is not idempotent <span style="color: red"> because </span> <span style="color: red"> its </span> <span style="color: red"> effect </span> <span style="color: red"> is </span> established <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> origin </span> <span style="color: red"> server </span> <span style="color: red"> and </span> <span style="color: red"> dependent </span> <span style="color: red"> on </span> <span style="color: red"> the </span> <span style="color: red"> target </span> <span style="color: red"> resource. </span> put: result in the creation or update of the resource specified by the uri given. its response codes are the same of post. put is idempotent but not safe. delete: results in the deletion of <span style="color: red"> the </span> <span style="color: red"> resource </span> <span style="color: red"> identified </span> <span style="color: red"> by </span> <span style="color: red"> the </span> uri given. if succeed, <span style="color: red"> a </span> <span style="color: red"> 2.02 </span> <span style="color: red"> (deleted) </span> <span style="color: red"> response </span> <span style="color: red"> code </span> is returned. delete is idempotent but not safe.  c. proxying proxies can serve many different purposes; we can distinguish them in 3 main types: • forward-proxies: coap request on such proxies can be made as confirmable (con) or nonconfirmable (non), but <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> uri </span> <span style="color: red"> is </span> <span style="color: red"> specified </span> <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> proxy-uri </span> <span style="color: red"> option </span> instead of being split in <span style="color: red"> uri-host, </span> <span style="color: red"> uri-port, </span> <span style="color: red"> uri-path </span> <span style="color: red"> and </span> <span style="color: red"> uri-query </span> <span style="color: red"> options. </span> if the endpoint <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> act </span> <span style="color: red"> as </span> <span style="color: red"> a </span> proxy, it returns <span style="color: red"> a </span> <span style="color: red"> 5.05 </span> <span style="color: red"> (proxying </span> <span style="color: red"> not </span> <span style="color: red"> supported) </span> <span style="color: red"> response. </span> • reverse-proxies: offer various <span style="color: red"> resources </span> <span style="color: red"> as </span> <span style="color: red"> if </span> <span style="color: red"> they </span> <span style="color: red"> were </span> <span style="color: red"> its </span> <span style="color: red"> own </span> resources. • cross-proxies: can translate a coap request/response to a different protocol. more specifically, a particular kind of cross-proxying is of interest in iot when using coap, that is the crossprotocol <span style="color: red"> proxying </span> <span style="color: red"> between </span> <span style="color: red"> coap </span> <span style="color: red"> and </span> <span style="color: red"> http, </span> that’s because coap support <span style="color: red"> a </span> <span style="color: red"> limited </span> <span style="color: red"> subset </span> <span style="color: red"> of </span> <span style="color: red"> http </span> functionalities. <span style="color: red"> only </span> <span style="color: red"> the </span> <span style="color: red"> request/response </span> <span style="color: red"> model </span> <span style="color: red"> of </span> <span style="color: red"> coap </span> <span style="color: red"> is </span> <span style="color: red"> mapped </span> <span style="color: red"> to </span> <span style="color: red"> http. </span> <span style="color: red"> the </span> confirmable/non-confirmable messages model is invisible and has <span style="color: red"> no </span> <span style="color: red"> effect </span> <span style="color: red"> on </span> <span style="color: red"> a </span> <span style="color: red"> proxy </span> <span style="color: red"> function. </span> <span style="color: red">  </span> <span style="color: red"> the </span> <span style="color: red"> difference </span> <span style="color: red"> between </span> post and put is that put  6  methods get put post delete  description <span style="color: red"> retrieves </span> <span style="color: red"> a </span> <span style="color: red"> representation </span> <span style="color: red"> of </span> information corresponding to the specified uri requests to update the identified resource be updated with the enclosed representation, or create new request to process the enclosed representation delete <span style="color: red"> the </span> <span style="color: red"> resource </span> <span style="color: red"> identified </span> <span style="color: red"> by </span> <span style="color: red"> the </span> uri table 3: coap methods  coap-http proxying: <span style="color: red"> enables </span> <span style="color: red"> coap </span> <span style="color: red"> clients </span> <span style="color: red"> to </span> <span style="color: red"> access </span> <span style="color: red"> resources </span> that are hosted on a http server. when sending a request to the coap-http proxy, a coap client has to set <span style="color: red"> the </span> <span style="color: red"> proxy-uri </span> <span style="color: red"> or </span> <span style="color: red"> proxy-scheme </span> <span style="color: red"> option </span> to ”http” or ”https”. since <span style="color: red"> the </span> <span style="color: red"> basic </span> <span style="color: red"> methods </span> <span style="color: red"> of </span> coap <span style="color: red"> are </span> <span style="color: red"> very </span> <span style="color: red"> similar </span> <span style="color: red"> to </span> <span style="color: red"> http, </span> performing a request is not much different. <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> service the request with the http uri, it returns <span style="color: red"> a </span> <span style="color: red"> 5.05 </span> <span style="color: red"> (proxying </span> <span style="color: red"> not </span> <span style="color: red"> supported) </span> <span style="color: red"> response. </span> <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> unable </span> to get the requested resource by the http server in a given timeframe, it returns <span style="color: red"> a </span> <span style="color: red"> 5.04 </span> <span style="color: red"> (gateway </span> <span style="color: red"> timeout) </span> <span style="color: red"> response. </span> <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> resource </span> is not understood, it returns <span style="color: red"> a </span> <span style="color: red"> 5.02 </span> <span style="color: red"> (bad </span> <span style="color: red"> gateway) </span> <span style="color: red"> response. </span> the response payload <span style="color: red"> is </span> <span style="color: red"> a </span> <span style="color: red"> representation </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> resource, </span> <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> content-format </span> <span style="color: red"> option </span> should be set accordingly. http-coap proxying: <span style="color: red"> enables </span> <span style="color: red"> http </span> <span style="color: red"> clients </span> <span style="color: red"> to </span> <span style="color: red"> access </span> <span style="color: red"> resources </span> hosted on coap servers. when sending a request to the http-coap proxy, an http client has to set the request-line to ”coap” or ”coaps”. <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> service the request with the coap uri, it returns <span style="color: red"> a </span> <span style="color: red"> 501 </span> <span style="color: red"> (not </span> <span style="color: red"> implemented) </span> response. <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> get the requested resource <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> server </span> in a given timeframe, it returns <span style="color: red"> a </span> <span style="color: red"> 504 </span> <span style="color: red"> (gateway </span> <span style="color: red"> timeout) </span> <span style="color: red"> response. </span> <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> resource </span> is not understood, it returns <span style="color: red"> a </span> <span style="color: red"> 502 </span> <span style="color: red"> (bad </span> <span style="color: red"> gateway) </span> response. since the methods option, trace and connect are not implemented in coap, if those one are called, the proxy returns <span style="color: red"> a </span> <span style="color: red"> 501 </span> <span style="color: red"> (not </span> <span style="color: red"> implemented) </span> error.  increasing, coap over tcp was proposed in [4]. tcp has <span style="color: red"> congestion </span> <span style="color: red"> control </span> <span style="color: red"> and </span> <span style="color: red"> flow </span> <span style="color: red"> control </span> mechanism, more sophisticated that the one <span style="color: red"> of </span> <span style="color: red"> coap </span> <span style="color: red"> over </span> <span style="color: red"> udp, </span> but uses a larger packet <span style="color: red"> size, </span> <span style="color: red"> more </span> <span style="color: red"> round </span> <span style="color: red"> trips, </span> and increased ram requirements. the main <span style="color: red"> difference </span> <span style="color: red"> between </span> <span style="color: red"> coap </span> <span style="color: red"> over </span> <span style="color: red"> tcp </span> <span style="color: red"> and </span> over udp is on the message layer, while the request/response model remains the same. messaging model: since tcp provides reliable transmission, <span style="color: red"> coap </span> <span style="color: red"> confirmable </span> <span style="color: red"> and </span> <span style="color: red"> acknowledge </span> <span style="color: red"> message </span> are no longer needed. so, <span style="color: red"> the </span> <span style="color: red"> message </span> <span style="color: red"> id </span> <span style="color: red"> field </span> and the type <span style="color: red"> field </span> <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> header </span> <span style="color: red"> are </span> not present anymore, instead, 2 fields that indicate <span style="color: red"> the </span> <span style="color: red"> length </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> message </span> <span style="color: red"> (length </span> and extended length) are present because tcp does not provide this information. message format: is very similar of the one over udp, except for type, message id and version fields that are removed as previously said. this format <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 11. message transmission: after the tcp connection is established, the coap endpoints send a csm (capabilities and settings message) as first message of the connection. this special message initializes the settings and capabilities of the endpoints, if <span style="color: red"> there </span> <span style="color: red"> are </span> <span style="color: red"> no </span> <span style="color: red"> options </span> set in this message, the defaults are used. <span style="color: red"> request </span> <span style="color: red"> and </span> <span style="color: red"> response </span> <span style="color: red"> are </span> <span style="color: red"> sent </span> asynchronously over the transport connection. so, a <span style="color: red"> client </span> <span style="color: red"> can </span> <span style="color: red"> send </span> <span style="color: red"> multiple </span> <span style="color: red"> requests </span> without waiting for responses, and those responses can be returned in any order but in the same connection. the tcp protocol is bidirectional, this implies that requests and responses have the capability to <span style="color: red"> be </span> <span style="color: red"> sent </span> <span style="color: red"> by </span> <span style="color: red"> both </span> endpoints. tcp also support retransmission and duplication of messages.  vi. c oap enhancements in this section <span style="color: red"> we </span> <span style="color: red"> are </span> <span style="color: red"> going </span> <span style="color: red"> to </span> review some enhancements and extensions of the standard coap protocol. in particular we explore <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> over </span> <span style="color: red"> tcp </span> <span style="color: red"> and </span> <span style="color: red"> coap </span> for streaming.  b. coap for streaming in the last years, <span style="color: red"> a </span> <span style="color: red"> variety </span> <span style="color: red"> of </span> <span style="color: red"> streaming </span> <span style="color: red"> application </span> in iot are becoming more common. in this paper [5] the authors explore the usage <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> protocol </span> <span style="color: red"> for </span> this particular type of flow of data. the conventional coap over udp <span style="color: red"> or </span> <span style="color: red"> coap </span> <span style="color: red"> over </span> <span style="color: red"> tcp </span> protocols <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> used </span> <span style="color: red"> for </span> <span style="color: red"> reliable </span> <span style="color: red"> services </span> as we seen. however, they do not implement <span style="color: red"> error </span> <span style="color: red"> handling </span> <span style="color: red"> and </span> <span style="color: red"> flow </span> <span style="color: red"> controls </span> suitable to help the transmission of streaming data at the sender, this  a. coap over tcp the standard coap operates above the <span style="color: red"> user </span> <span style="color: red"> datagram </span> <span style="color: red"> protocol </span> <span style="color: red"> (udp) </span> accomplishing lightweight messaging. but the main downsides are that udp cannot provide reliability and some networks, especially enterprise networks, do not froward udp packets. for those reasons and that the demand <span style="color: red"> for </span> <span style="color: red"> the </span> <span style="color: red"> use </span> <span style="color: red"> of </span> tcp in iot is  7  fig. 11: coap over tcp message format <span style="color: red">  </span> <span style="color: red"> leads </span> <span style="color: red"> to </span> <span style="color: red"> a </span> degradation of the throughput performances, especially in sensor wireless lossy networks. for example, if <span style="color: red"> in </span> <span style="color: red"> coap </span> <span style="color: red"> over </span> <span style="color: red"> udp </span> <span style="color: red"> a </span> message gets lost, its retransmission will happen after a timeout, making the error recovery to increase transmission delays. in coap over tcp the packet can be recovered quickly using the tcp fast recovery, but this mechanism adds overhead in the iot environment. moreover, <span style="color: red"> the </span> <span style="color: red"> complexity </span> <span style="color: red"> of </span> <span style="color: red"> tcp </span> is not very suitable for real time streaming in iot environment. to overcome these issues, the authors in [5] proposed a streaming control based on the coap, called coap-sc, which extends <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> over </span> <span style="color: red"> udp </span> protocol that enhance the throughput by adding <span style="color: red"> error </span> <span style="color: red"> handling </span> <span style="color: red"> and </span> <span style="color: red"> flow </span> <span style="color: red"> controls </span> mechanism. the <span style="color: red"> scheme </span> <span style="color: red"> is </span> <span style="color: red"> designed </span> <span style="color: red"> by </span> assigning a sequence number (sn) to each data message, and an <span style="color: red"> ack </span> <span style="color: red"> number </span> <span style="color: red"> (an) </span> <span style="color: red"> is </span> returned by the receiver. initialization for coap-sc: <span style="color: red"> with </span> <span style="color: red"> a </span> <span style="color: red"> post </span> <span style="color: red"> message </span> the sender <span style="color: red"> requests </span> <span style="color: red"> the </span> <span style="color: red"> creation </span> <span style="color: red"> of </span> <span style="color: red"> a </span> new resource, this request include authentication information, buffer size and other parameters correlated with the streaming service. after the creation of the resource, the receiver returns a 2.01 response message with the url of this new resource. then, <span style="color: red"> the </span> <span style="color: red"> sender </span> <span style="color: red"> sends </span> <span style="color: red"> a </span> <span style="color: red"> get </span> <span style="color: red"> request </span> <span style="color: red"> to </span> that <span style="color: red"> url, </span> <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> receiver </span> <span style="color: red"> responds </span> back with a 2.05 response message. all get and their response messages contains a <span style="color: red"> sequence </span> <span style="color: red"> number </span> <span style="color: red"> (sn) </span> <span style="color: red"> and </span> <span style="color: red"> ack </span> <span style="color: red"> number </span> (an), where <span style="color: red"> sn </span> <span style="color: red"> is </span> <span style="color: red"> sequentially </span> <span style="color: red"> assigned </span> on each message sent by the sender, and the an is set <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> receiver </span> <span style="color: red"> to </span> tell that that message was received correctly. the an is cumulative. <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> initialization </span> <span style="color: red"> process </span> sn and an are set to 0. this initialization process <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig 12. error handling for coap-sc: the first message sent by the sender has sn=1 and an=0. every time the receiver gets a message, it updates its own an number to be equal to the highest sn value that has been received and cumulatively. so, if <span style="color: red"> the </span> <span style="color: red"> receiver </span> <span style="color: red"> is </span> <span style="color: red"> not </span> getting <span style="color: red"> any </span> <span style="color: red"> data </span> <span style="color: red"> message </span> <span style="color: red"> for </span> <span style="color: red"> a </span> certain amount of <span style="color: red"> time, </span> <span style="color: red"> it </span> <span style="color: red"> sends </span> <span style="color: red"> an </span> <span style="color: red"> ack </span> <span style="color: red"> message </span> <span style="color: red"> to </span> tell the sender the  fig. 12: coap-sc initialization an status. in the normal streaming flow, the recipient will receive a message that has sn = ansent <span style="color: red"> + </span> <span style="color: red"> 1, </span> <span style="color: red"> and </span> <span style="color: red"> the </span> next message it will send, will have an = snreceived = ansent + 1. so, if a message gets lost, the receiver will determine that by checking if this condition is true: snreceived − ansent > 1. when this message loss is found, <span style="color: red"> the </span> <span style="color: red"> receiver </span> <span style="color: red"> sends </span> <span style="color: red"> an </span> <span style="color: red"> ack </span> <span style="color: red"> message </span> for a retransmission request that includes the sn of <span style="color: red"> the </span> <span style="color: red"> message </span> <span style="color: red"> to </span> <span style="color: red"> be </span> transmitted, and this ack is retransmitted until the data lost is correctly received. an example of this mechanism <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 13. flow control for coap-sc: ack messages are used also for flow control, by providing the newest <span style="color: red"> an </span> <span style="color: red"> information </span> <span style="color: red"> to </span> <span style="color: red"> the </span> sender, in this way facilitating it to  8  fig. 14: coap-sc message option format vii. c oncluding r emarks in this paper an overview <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> coap </span> <span style="color: red"> protocol </span> <span style="color: red"> has </span> given. since the basic architecture of coap may perform inefficiently in some scenarios like when strong reliability is needed and <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> case </span> <span style="color: red"> of </span> streaming applications, we proposed possible solutions for those problems taken from the most recent literature. in particular for reliability, a rfc called ”coap over tcp” that as its title says, modifies coap to work on the reliable transport protocol tcp. while for the streaming scenario, a modification called coap-sc was reviewed, that propose good a mechanism to deal with errors and flow control that are crucial in streaming. however, it is quite clear that this streaming scheme needs some other modifications <span style="color: red"> to </span> <span style="color: red"> reduce </span> <span style="color: red"> the </span> <span style="color: red"> packet </span> <span style="color: red"> size </span> to be applied in the iot environment. viii. acknowledgment all images are made by stefano ivancich. this work is presented for the final grade of the ”internet of things and smart cities” course, held by prof. lorenzo vangelista at the university of padova in 2021. r eferences [1] m. belshe, r. peon, and m. thomson, “hypertext <span style="color: red"> transfer </span> <span style="color: red"> protocol </span> <span style="color: red"> version </span> <span style="color: red"> 2 </span> (http/2).” rfc 7540, may 2015. [2] z. shelby, k. hartke, and c. bormann, “the constrained application protocol (coap).” rfc 7252, june 2014. [3] z. shelby, “constrained <span style="color: red"> restful </span> <span style="color: red"> environments </span> <span style="color: red"> (core) </span> <span style="color: red"> link </span> format.” rfc 6690, aug. 2012. [4] c. bormann, s. lemay, h. tschofenig, k. hartke, b. silverajan, and b. raymor, “coap <span style="color: red"> (constrained </span> <span style="color: red"> application </span> <span style="color: red"> protocol) </span> <span style="color: red"> over </span> <span style="color: red"> tcp, </span> <span style="color: red"> tls, </span> <span style="color: red"> and </span> websockets.” rfc 8323, feb. 2018. [5] j.-h. jung, m. gohar, and s.-j. koh, “coap-based streaming control for iot applications,” electronics, vol. 9, no. 8, 2020.  fig. 13: coap-sc error handling example transfer <span style="color: red"> as </span> <span style="color: red"> much </span> <span style="color: red"> data </span> <span style="color: red"> as </span> possible, resulting a throughput enhancement. <span style="color: red">  </span> <span style="color: red"> coap </span> <span style="color: red"> option </span> <span style="color: red"> for </span> coap-sc: the option header is composed by 4bit option delta, 4-bit option length, 4-byte sequence number and 4-byte ack number. this option format <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> seen </span> <span style="color: red"> in </span> fig. 14.  9  