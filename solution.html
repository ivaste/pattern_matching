An overview of the CoAP protocol architecture, features and its extensions Stefano Ivancich Department of Information Engineering (DEI) University of Padova, Italy Email: stefano.ivancich@studenti.unipd.it Student ID: 1227846  systems, which rules the communication between Web clients and Web servers. It’s used mostly for transfer HTML documents between nodes. At its basis it is a textual request-response protocol where clients and servers exchange messages constituted by an header and an optional body. Is a stateless protocol, that basically means that each request-response is independent and neither the client nor the server has to keep trace of the exchanged messages. This simplifies the implementation of the protocol and makes it more scalable. And is designed to favors the use of intermediaries or proxies, typically for caching or security purposes. It is well suited for nodes with relatively high computational power, but often it can be too demanding in terms of bandwidth and processing requirements for the constrained devices that we are considering in the IoT scenario. So, a protocol called <span style="color: red"> Constrained </span> <span style="color: red"> Application </span> <span style="color: red"> Protocol </span> <span style="color: red"> (CoAP) </span> defined in the RFC 7252 [2] was developed as a lightweight counterpart of HTTP in order to simplify integration with the web but at the same time address the needs of constrained devices and constrained networks, indeed <span style="color: red"> nodes </span> <span style="color: red"> often </span> <span style="color: red"> have </span> <span style="color: red"> 8-bit </span> <span style="color: red"> microcontrollers </span> <span style="color: red"> with </span> <span style="color: red"> small </span> <span style="color: red"> amounts </span> <span style="color: red"> of </span> <span style="color: red"> ROM </span> <span style="color: red"> and </span> <span style="color: red"> RAM, </span> <span style="color: red"> while </span> <span style="color: red"> constrained </span> networks <span style="color: red"> often </span> <span style="color: red"> have </span> <span style="color: red"> high </span> <span style="color: red"> packet </span> <span style="color: red"> error </span> <span style="color: red"> rates </span> <span style="color: red"> and </span> an indicative throughput of 10s kbit/s. This protocol is used for machine-to-machine (M2M) communication and, as said before, is quite similar to HTTP, but with some relevant differences. It uses smaller and simplified headers, supports asynchronous REST, publish/subscribe message exchanges, provides <span style="color: red"> multicast </span> <span style="color: red"> support, </span> <span style="color: red"> very </span> <span style="color: red"> low </span> <span style="color: red"> overhead, </span> <span style="color: red"> and </span> <span style="color: red"> simplicity </span> <span style="color: red"> for </span> <span style="color: red"> constrained </span> environments. The aim <span style="color: red"> of </span> <span style="color: red"> CoAP </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> to </span> indiscriminately compress the HTTP protocol, but instead to provide a subgroup of REST in common with HTTP that are optimized for M2M communications. In this work, we focus on the IoT communication protocol CoAP; in particular, we overview its architecture,  Fig. 1: Stefano Ivancich in 2021 Abstract—Today (2021), several billions of devices are connected daily to the internet, so a very huge amount of a data is sent and managed every second. In the next years, it is expected that even more devices like sensors, actuators for domestic or industrial usage will connect to the internet. In this context, we review an HTTP like protocol called <span style="color: red"> Constrained </span> <span style="color: red"> Application </span> <span style="color: red"> Protocol </span> <span style="color: red"> (CoAP) </span> that was developed by the Internet of Engineering Task (IETF) to work on constrained IoT devices operating in lossy environments. Although this protocol is lightweight and efficient compared to other IoT protocols such as HTTP or MQTT, it has some limitation in some scenarios, for example when strong reliability is needed or in streaming applications. For this reason we also overview, from the most recent literature some modifications, one is CoAP over TCP that guarantee reliability, another is CoAP-SC that has a good mechanism to handle with error and flow control that are crucial in streaming applications. Index Terms—CoAP, IoT, TCP, UDP, Streaming, enhancements in CoAP  I. I NTRODUCTION The Hypertext Transfer Protocol (HTTP) [1] is one of the most widely used application layer protocol for distributed, collaborative, hypermedia information  1  Codes. Both request <span style="color: red"> and </span> <span style="color: red"> responses </span> <span style="color: red"> can </span> <span style="color: red"> be </span> confirmable or non-confirmable. We can think of CoAP a two-layer protocol, one layer for messaging that deal with the transport layer and with asynchronous messages, and a Request/Response layer that manages request/response interactions <span style="color: red"> using </span> <span style="color: red"> Method </span> <span style="color: red"> and </span> <span style="color: red"> Response </span> Codes. You can see this in Fig. 2.  features and extensions. The report is structured as follows: in Section II we describe the communication problems in constrained networks, in Section III we give an overview of the CoAP protocol that tackle those problems, and in Section ?? we describe it’s message format, it’s transmission and semantic. In Section ?? we describe the CoAP methods definitions, caching and proxying. In Section ?? we review some extension and modifications of the standard CoAP protocol. And finally in Section ?? we make some extra considerations on future developments and possible improvements. II. C ONSTRAINED D EVICES AND N ETWORKS Edge networks may operate in a huge variety of environments and conditions that requires a careful attention on their use. Usually, data flowing throw edge networks are ultimately destined for the Internet, so they should be designed with that transition in mind and therefore it makes some sense to emulate some ideas in IoT edge network design. The so-called Constrained networks are characterized as Low-Power and Lossy Networks (LLNs). Those kinds of networks are used often in combination with constrained devices that, have limited processing and powers supply, in Table 1 you can see a classification of constrained devices. LLNs are constrained because the cost, the limited nodes capabilities, limited power, limited spectrum, high density and interference. So they need smaller (compressed) headers and smaller payloads/packets to keep bit error rates low and permit media sharing. That’s where lightweight communication protocols like CoAP comes into play.  Fig. 2: <span style="color: red"> Abstract </span> <span style="color: red"> Layering </span> <span style="color: red"> of </span> <span style="color: red"> CoAP </span> Now we are going to explain these 2 layers in depth. A. Messaging Model The message layer is the lowest layer of CoAP and <span style="color: red"> is </span> <span style="color: red"> based </span> <span style="color: red"> on </span> <span style="color: red"> the </span> <span style="color: red"> exchange </span> <span style="color: red"> of </span> <span style="color: red"> messages </span> <span style="color: red"> over </span> the transport layer, in the base case the UDP datagrams, but in the following section we will see how it adapts to TCP. CoAP uses a binary header of fixed length (4 bytes), that <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> followed </span> <span style="color: red"> by </span> a <span style="color: red"> compact </span> <span style="color: red"> binary </span> <span style="color: red"> options </span> <span style="color: red"> and </span> the payload. Each CoAP message has a unique ID (16-bit) used <span style="color: red"> to </span> <span style="color: red"> detect </span> <span style="color: red"> duplicates </span> <span style="color: red"> and </span> <span style="color: red"> for </span> reliability, allowing an exchange of up to 250 messages per second. A message can be sent reliably <span style="color: red"> if </span> <span style="color: red"> it </span> <span style="color: red"> is </span> <span style="color: red"> of </span> type Confirmable (CON), a response will be provided with the Acknowledgement message (ACK) type <span style="color: red"> with </span> <span style="color: red"> the </span> <span style="color: red"> same </span> <span style="color: red"> Message </span> <span style="color: red"> ID </span> or with the Reset message (RST) if the receiver <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> process </span> <span style="color: red"> the </span> <span style="color: red"> message </span> sent. This process can be seen in Fig. 3. A non-reliable message can be sent as Nonconfirmable message (NON) that won’t have any acknowledge response, but if the recipient has some troubles processing such message, it can reply with the Reset message (RST). Even if these messages are unreliable, they have a unique ID. This process can be seen in Fig. 4. CoAP message types <span style="color: red"> are </span> <span style="color: red"> summarized </span> <span style="color: red"> in </span> <span style="color: red"> Table </span> 2.  III. C ONSTRAINED A PPLICATION P ROTOCOL (C OAP) The way CoAP interact is very similar to the HTTP client/server model, but is common to use a node performing both client and server. A CoAP request <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> by </span> <span style="color: red"> a </span> <span style="color: red"> client </span> <span style="color: red"> to </span> <span style="color: red"> a </span> server in order to request an action (specified with a Method Code parameter) on a particular resource identified by an URI. Then the server returns a response containing a Response Code, with the resource or an error message. CoAP differs from HTTP when dealing these messages exchanges because it handles them asynchronously over the transport layer (in this case the UDP, in section ?? we will see how CoAP works over TCP). 4 types of message are supported by CoAP: Confirmable, Non-confirmable, Acknowledgement and Reset. Those messages can transport request or responses based on their Method Codes or Response  2  Name  Data size (eg. RAM)  Code Size (eg. ROM)  Class 0, C0   10KB   100KB  Class 1, C1  ∼10KB  ∼100KB  Class 2, C2  ∼50KB  ∼250KB  Functionality Very constrained devices. Cannot communicate with the Internet directly. IP and security capable, cannot easily communicate using full IP stacks, such as HTTP. May be able to use CoAP over UDP. Support most protocol stacks.  TABLE 1: Classification of constrained devices Message type Confirmable Non-Confirmable Reset Acknowledgment  Description Reliable message delivery, the recipient is required to confirm with an acknowledgment Not acknowledged, delivery is not guaranteed Indicates that a message was received, but the <span style="color: red"> recipient </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> process </span> it Indicates that the message was received and processed correctly TABLE 2: CoAP message types  sponse. This process can be seen in Fig. 5.  Fig. 3: Reliable message transmission  Fig. 5: Example of GET Requests that receive Piggybacked Responses <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> server </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> respond </span> <span style="color: red"> immediately </span> <span style="color: red"> to </span> the Confirmable message, it sends back and empty ACK message, otherwise the client will continue to retransmit the request. And when it’s ready to respond, it sends <span style="color: red"> a </span> <span style="color: red"> Confirmable </span> <span style="color: red"> message </span> <span style="color: red"> with </span> the content that must be confirmed with an ACK message from the client. This mechanism is called ”separate response” and can be seen in Fig. 6. Instead, <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> is </span> sent by using a Nonconfirmable message (NON), the response is sent also as Non-confirmable that you can see in Fig. 7.  Fig. 4: Unreliable message transmission B. Request/Response Model The CoAP Request/Response is the top abstract layer. Request and responses are carried by the CoAP messages, that includes <span style="color: red"> a </span> <span style="color: red"> Method </span> <span style="color: red"> Code </span> <span style="color: red"> or </span> a Response code. A <span style="color: red"> Token </span> <span style="color: red"> is </span> <span style="color: red"> used </span> <span style="color: red"> to </span> pair <span style="color: red"> the </span> <span style="color: red"> response </span> <span style="color: red"> to </span> <span style="color: red"> the </span> corresponding request. The request <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> using </span> <span style="color: red"> a </span> <span style="color: red"> Confirmable </span> <span style="color: red"> (CON) </span> <span style="color: red"> or </span> <span style="color: red"> Non-confirmable </span> <span style="color: red"> (NON) </span> message. <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> by </span> <span style="color: red"> a </span> Confirmable message, <span style="color: red"> the </span> <span style="color: red"> server </span> <span style="color: red"> responds </span> <span style="color: red"> with </span> an Acknowledgement (ACK) message with the resource or with an Error Code, this is called piggybacked Re-  C. Intermediaries, Caching and Resource Discovery To fulfill request efficiently CoAP offer the caching of responses. Since we are working on constrained networks, CoAP also offer the possibility of creating a proxy, this is due to restrain network traffic, boost performances, to access to the data of devices in sleep mode, and to provide security. Like in HTTP proxying,  3  IV. ACKNOWLEDGMENT This work is presented for the final grade of the ”Internet of Things and Smart Cities” course, held by prof. Lorenzo Vangelista at the University of Padova in 2021. R EFERENCES [1] M. Belshe, R. Peon, and M. Thomson, “Hypertext Transfer Protocol Version 2 (HTTP/2).” RFC 7540, May 2015. [2] Z. Shelby, K. Hartke, and C. Bormann, “The Constrained Application Protocol (CoAP).” RFC 7252, June 2014.  Fig. 6: <span style="color: red"> A </span> <span style="color: red"> GET </span> <span style="color: red"> Request </span> <span style="color: red"> with </span> <span style="color: red"> a </span> <span style="color: red"> Separate </span> <span style="color: red"> Response </span> <span style="color: red">  </span> Fig. 7: <span style="color: red"> A </span> <span style="color: red"> Request </span> <span style="color: red"> and </span> <span style="color: red"> a </span> <span style="color: red"> Response </span> <span style="color: red"> Carried </span> <span style="color: red"> in </span> Nonconfirmable Messages <span style="color: red"> the </span> <span style="color: red"> destination </span> <span style="color: red"> IP </span> <span style="color: red"> address </span> is <span style="color: red"> the </span> <span style="color: red"> address </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> while the resource’s URI is inside the request. There is also the possibility to map <span style="color: red"> CoAP </span> <span style="color: red"> to </span> <span style="color: red"> HTTP </span> <span style="color: red"> and </span> the other way around. This conversion can be realized by a cross-proxy (a cross-protocol proxy) that converts Method/Response codes, options o the corresponding in HTTP. As final note of this section, since <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> context </span> <span style="color: red"> of </span> M2M interactions Resource Discovery is pretty important, CoAP support it <span style="color: red"> using </span> <span style="color: red"> the </span> <span style="color: red"> CoRE </span> <span style="color: red"> Link </span> Format.  4  