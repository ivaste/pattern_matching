An overview of the CoAP protocol architecture,
features and its extensions
Stefano Ivancich
Department of Information Engineering (DEI)
University of Padova, Italy
Email: stefano.ivancich@studenti.unipd.it
Student ID: 1227846

systems, which rules the communication between Web
clients and Web servers. It’s used mostly for transfer
HTML documents between nodes. At its basis it is
a textual request-response protocol where clients and
servers exchange messages constituted by an header and
an optional body. Is a stateless protocol, that basically
means that each request-response is independent and
neither the client nor the server has to keep trace
of the exchanged messages. This simplifies the implementation of the protocol and makes it more scalable.
And is designed to favors the use of intermediaries or
proxies, typically for caching or security purposes. It
is well suited for nodes with relatively high computational power, but often it can be too demanding in
terms of bandwidth and processing requirements for the
constrained devices that we are considering in the IoT
scenario. So, a protocol called Constrained Application
Protocol (CoAP) defined in the RFC 7252 [2] was
developed as a lightweight counterpart of HTTP in order
to simplify integration with the web but at the same
time address the needs of constrained devices and constrained networks, indeed nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while
constrained networks often have high packet error rates
and an indicative throughput of 10s kbit/s. This protocol
is used for machine-to-machine (M2M) communication
and, as said before, is quite similar to HTTP, but with
some relevant differences. It uses smaller and simplified
headers, supports asynchronous REST, publish/subscribe
message exchanges, provides multicast support, very low
overhead, and simplicity for constrained environments.
The aim of CoAP is not to indiscriminately compress
the HTTP protocol, but instead to provide a subgroup
of REST in common with HTTP that are optimized for
M2M communications.
In this work, we focus on the IoT communication protocol CoAP; in particular, we overview its architecture,

Fig. 1: Stefano Ivancich in 2021
Abstract—Today (2021), several billions of devices are
connected daily to the internet, so a very huge amount of a
data is sent and managed every second. In the next years,
it is expected that even more devices like sensors, actuators
for domestic or industrial usage will connect to the
internet. In this context, we review an HTTP like protocol
called Constrained Application Protocol (CoAP) that was
developed by the Internet of Engineering Task (IETF)
to work on constrained IoT devices operating in lossy
environments. Although this protocol is lightweight and
efficient compared to other IoT protocols such as HTTP
or MQTT, it has some limitation in some scenarios, for
example when strong reliability is needed or in streaming
applications. For this reason we also overview, from the
most recent literature some modifications, one is CoAP
over TCP that guarantee reliability, another is CoAP-SC
that has a good mechanism to handle with error and flow
control that are crucial in streaming applications.
Index Terms—CoAP, IoT, TCP, UDP, Streaming, enhancements in CoAP

I. I NTRODUCTION
The Hypertext Transfer Protocol (HTTP) [1] is one
of the most widely used application layer protocol
for distributed, collaborative, hypermedia information

1

Codes. Both request and responses can be confirmable
or non-confirmable. We can think of CoAP a two-layer
protocol, one layer for messaging that deal with the
transport layer and with asynchronous messages, and a
Request/Response layer that manages request/response
interactions using Method and Response Codes. You can
see this in Fig. 2.

features and extensions.
The report is structured as follows: in Section II we
describe the communication problems in constrained
networks, in Section III we give an overview of the
CoAP protocol that tackle those problems, and in Section ?? we describe it’s message format, it’s transmission
and semantic. In Section ?? we describe the CoAP
methods definitions, caching and proxying. In Section
?? we review some extension and modifications of the
standard CoAP protocol. And finally in Section ?? we
make some extra considerations on future developments
and possible improvements.
II. C ONSTRAINED D EVICES AND N ETWORKS
Edge networks may operate in a huge variety of
environments and conditions that requires a careful
attention on their use. Usually, data flowing throw edge
networks are ultimately destined for the Internet, so they
should be designed with that transition in mind and
therefore it makes some sense to emulate some ideas
in IoT edge network design. The so-called Constrained
networks are characterized as Low-Power and Lossy
Networks (LLNs). Those kinds of networks are used
often in combination with constrained devices that, have
limited processing and powers supply, in Table 1 you
can see a classification of constrained devices. LLNs are
constrained because the cost, the limited nodes capabilities, limited power, limited spectrum, high density and
interference. So they need smaller (compressed) headers
and smaller payloads/packets to keep bit error rates
low and permit media sharing. That’s where lightweight
communication protocols like CoAP comes into play.

Fig. 2: Abstract Layering of CoAP
Now we are going to explain these 2 layers in depth.
A. Messaging Model
The message layer is the lowest layer of CoAP and
is based on the exchange of messages over the transport
layer, in the base case the UDP datagrams, but in the
following section we will see how it adapts to TCP.
CoAP uses a binary header of fixed length (4 bytes),
that can be followed by a compact binary options and the
payload. Each CoAP message has a unique ID (16-bit)
used to detect duplicates and for reliability, allowing an
exchange of up to 250 messages per second. A message
can be sent reliably if it is of type Confirmable (CON),
a response will be provided with the Acknowledgement
message (ACK) type with the same Message ID or with
the Reset message (RST) if the receiver is not able to
process the message sent. This process can be seen in
Fig. 3.
A non-reliable message can be sent as Nonconfirmable message (NON) that won’t have any acknowledge response, but if the recipient has some troubles processing such message, it can reply with the Reset
message (RST). Even if these messages are unreliable,
they have a unique ID. This process can be seen in Fig.
4. CoAP message types are summarized in Table 2.

III. C ONSTRAINED A PPLICATION P ROTOCOL
(C OAP)
The way CoAP interact is very similar to the HTTP
client/server model, but is common to use a node performing both client and server. A CoAP request is sent
by a client to a server in order to request an action
(specified with a Method Code parameter) on a particular
resource identified by an URI. Then the server returns a
response containing a Response Code, with the resource
or an error message. CoAP differs from HTTP when
dealing these messages exchanges because it handles
them asynchronously over the transport layer (in this
case the UDP, in section ?? we will see how CoAP
works over TCP). 4 types of message are supported by
CoAP: Confirmable, Non-confirmable, Acknowledgement and Reset. Those messages can transport request
or responses based on their Method Codes or Response

2

Name

Data size
(eg. RAM)

Code Size
(eg. ROM)

Class 0, C0

 10KB

 100KB

Class 1, C1

∼10KB

∼100KB

Class 2, C2

∼50KB

∼250KB

Functionality
Very constrained devices.
Cannot communicate with the Internet directly.
IP and security capable, cannot easily communicate using full
IP stacks, such as HTTP. May be able to use CoAP over UDP.
Support most protocol stacks.

TABLE 1: Classification of constrained devices
Message type
Confirmable
Non-Confirmable
Reset
Acknowledgment

Description
Reliable message delivery, the recipient is required to confirm with an acknowledgment
Not acknowledged, delivery is not guaranteed
Indicates that a message was received, but the recipient is not able to process it
Indicates that the message was received and processed correctly
TABLE 2: CoAP message types

sponse. This process can be seen in Fig. 5.

Fig. 3: Reliable message transmission

Fig. 5: Example of GET Requests that receive Piggybacked Responses
If the server is not able to respond immediately to
the Confirmable message, it sends back and empty ACK
message, otherwise the client will continue to retransmit
the request. And when it’s ready to respond, it sends
a Confirmable message with the content that must be
confirmed with an ACK message from the client. This
mechanism is called ”separate response” and can be seen
in Fig. 6.
Instead, if the request is sent by using a Nonconfirmable message (NON), the response is sent also
as Non-confirmable that you can see in Fig. 7.

Fig. 4: Unreliable message transmission
B. Request/Response Model
The CoAP Request/Response is the top abstract layer.
Request and responses are carried by the CoAP messages, that includes a Method Code or a Response code.
A Token is used to pair the response to the corresponding
request. The request is sent using a Confirmable (CON)
or Non-confirmable (NON) message. If the request is
sent by a Confirmable message, the server responds with
an Acknowledgement (ACK) message with the resource
or with an Error Code, this is called piggybacked Re-

C. Intermediaries, Caching and Resource Discovery
To fulfill request efficiently CoAP offer the caching
of responses. Since we are working on constrained
networks, CoAP also offer the possibility of creating
a proxy, this is due to restrain network traffic, boost
performances, to access to the data of devices in sleep
mode, and to provide security. Like in HTTP proxying,

3

IV. ACKNOWLEDGMENT
This work is presented for the final grade of the
”Internet of Things and Smart Cities” course, held by
prof. Lorenzo Vangelista at the University of Padova in
2021.
R EFERENCES
[1] M. Belshe, R. Peon, and M. Thomson, “Hypertext Transfer
Protocol Version 2 (HTTP/2).” RFC 7540, May 2015.
[2] Z. Shelby, K. Hartke, and C. Bormann, “The Constrained Application Protocol (CoAP).” RFC 7252, June 2014.

Fig. 6: A GET Request with a Separate Response

Fig. 7: A Request and a Response Carried in Nonconfirmable Messages
the destination IP address is the address of the proxy
while the resource’s URI is inside the request. There
is also the possibility to map CoAP to HTTP and the
other way around. This conversion can be realized by
a cross-proxy (a cross-protocol proxy) that converts
Method/Response codes, options o the corresponding
in HTTP. As final note of this section, since in the
context of M2M interactions Resource Discovery is
pretty important, CoAP support it using the CoRE Link
Format.

4

