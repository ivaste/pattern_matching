An overview of the CoAP protocol architecture, features and its extensions Stefano Ivancich Department of Information Engineering (DEI) University of Padova, Italy Email: stefano.ivancich@studenti.unipd.it Student ID: 1227846  systems, which rules the communication between Web clients and Web servers. It’s used mostly for transfer HTML documents between nodes. At its basis it is a textual request-response protocol where clients and servers exchange messages constituted by an header and an optional body. Is a stateless protocol, that basically means that each request-response is independent and neither the client nor the server has to keep trace of the exchanged messages. This simplifies the implementation of the protocol and makes it more scalable. And is designed to favors the use of intermediaries or proxies, typically for caching or security purposes. It is well suited for nodes with relatively high computational power, but often it can be too demanding in terms of bandwidth and processing requirements for the constrained devices that we are considering in the IoT scenario. So, a protocol called <span style="color: red"> Constrained </span> <span style="color: red"> Application </span> <span style="color: red"> Protocol </span> <span style="color: red"> (CoAP) </span> defined in the RFC 7252 [2] was developed as a lightweight counterpart of HTTP in order to simplify integration with the web but at the same time address the needs of constrained devices and constrained networks, indeed <span style="color: red"> nodes </span> <span style="color: red"> often </span> <span style="color: red"> have </span> <span style="color: red"> 8-bit </span> <span style="color: red"> microcontrollers </span> <span style="color: red"> with </span> <span style="color: red"> small </span> <span style="color: red"> amounts </span> <span style="color: red"> of </span> <span style="color: red"> ROM </span> <span style="color: red"> and </span> <span style="color: red"> RAM, </span> <span style="color: red"> while </span> <span style="color: red"> constrained </span> networks <span style="color: red"> often </span> <span style="color: red"> have </span> <span style="color: red"> high </span> <span style="color: red"> packet </span> <span style="color: red"> error </span> <span style="color: red"> rates </span> <span style="color: red"> and </span> an indicative throughput of 10s kbit/s. This protocol is used for machine-to-machine (M2M) communication and, as said before, is quite similar to HTTP, but with some relevant differences. It uses smaller and simplified headers, supports asynchronous REST, publish/subscribe message exchanges, provides <span style="color: red"> multicast </span> <span style="color: red"> support, </span> <span style="color: red"> very </span> <span style="color: red"> low </span> <span style="color: red"> overhead, </span> <span style="color: red"> and </span> <span style="color: red"> simplicity </span> <span style="color: red"> for </span> <span style="color: red"> constrained </span> environments. The aim <span style="color: red"> of </span> <span style="color: red"> CoAP </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> to </span> indiscriminately compress the HTTP protocol, but instead to provide a subgroup of REST in common with HTTP that are optimized for M2M communications. In this work, we focus on the IoT communication protocol CoAP; in particular, we overview its architecture,  Fig. 1: Stefano Ivancich in 2021 Abstract—Today (2021), several billions of devices are connected daily to the internet, so a very huge amount of a data is sent and managed every second. In the next years, it is expected that even more devices like sensors, actuators for domestic or industrial usage will connect to the internet. In this context, we review an HTTP like protocol called <span style="color: red"> Constrained </span> <span style="color: red"> Application </span> <span style="color: red"> Protocol </span> <span style="color: red"> (CoAP) </span> that was developed by the Internet of Engineering Task (IETF) to work on constrained IoT devices operating in lossy environments. Although this protocol is lightweight and efficient compared to other IoT protocols such as HTTP or MQTT, it has some limitation in some scenarios, for example when strong reliability is needed or in streaming applications. For this reason we also overview, from the most recent literature some modifications, one is CoAP over TCP that guarantee reliability, another is CoAP-SC that has a good mechanism to handle with error and flow control that are crucial in streaming applications. Index Terms—CoAP, IoT, TCP, UDP, Streaming, enhancements in CoAP  I. I NTRODUCTION The Hypertext Transfer Protocol (HTTP) [1] is one of the most widely used application layer protocol for distributed, collaborative, hypermedia information  1  Codes. Both request <span style="color: red"> and </span> <span style="color: red"> responses </span> <span style="color: red"> can </span> <span style="color: red"> be </span> confirmable or non-confirmable. We can think of CoAP a two-layer protocol, one layer for messaging that deal with the transport layer and with asynchronous messages, and a Request/Response layer that manages request/response interactions <span style="color: red"> using </span> <span style="color: red"> Method </span> <span style="color: red"> and </span> <span style="color: red"> Response </span> Codes. You can see this in Fig. 2.  features and extensions. The report is structured as follows: in Section II we describe the communication problems in constrained networks, in Section III we give an overview of the CoAP protocol that tackle those problems, and in Section IV we describe it’s message format, it’s transmission and semantic. In Section V we describe the CoAP methods definitions, caching and proxying. In Section VI we review some extension and modifications of the standard CoAP protocol. And finally in Section VII we make some extra considerations on future developments and possible improvements. II. C ONSTRAINED D EVICES AND N ETWORKS Edge networks may operate in a huge variety of environments and conditions that requires a careful attention on their use. Usually, data flowing throw edge networks are ultimately destined for the Internet, so they should be designed with that transition in mind and therefore it makes some sense to emulate some ideas in IoT edge network design. The so-called Constrained networks are characterized as Low-Power and Lossy Networks (LLNs). Those kinds of networks are used often in combination with constrained devices that, have limited processing and powers supply, in Table 1 you can see a classification of constrained devices. LLNs are constrained because the cost, the limited nodes capabilities, limited power, limited spectrum, high density and interference. So they need smaller (compressed) headers and smaller payloads/packets to keep bit error rates low and permit media sharing. That’s where lightweight communication protocols like CoAP comes into play.  Fig. 2: <span style="color: red"> Abstract </span> <span style="color: red"> Layering </span> <span style="color: red"> of </span> <span style="color: red"> CoAP </span> Now we are going to explain these 2 layers in depth. A. Messaging Model The message layer is the lowest layer of CoAP and <span style="color: red"> is </span> <span style="color: red"> based </span> <span style="color: red"> on </span> <span style="color: red"> the </span> <span style="color: red"> exchange </span> <span style="color: red"> of </span> <span style="color: red"> messages </span> <span style="color: red"> over </span> the transport layer, in the base case the UDP datagrams, but in the following section we will see how it adapts to TCP. CoAP uses a binary header of fixed length (4 bytes), that <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> followed </span> <span style="color: red"> by </span> a <span style="color: red"> compact </span> <span style="color: red"> binary </span> <span style="color: red"> options </span> <span style="color: red"> and </span> the payload. Each CoAP message has a unique ID (16-bit) used <span style="color: red"> to </span> <span style="color: red"> detect </span> <span style="color: red"> duplicates </span> <span style="color: red"> and </span> <span style="color: red"> for </span> reliability, allowing an exchange of up to 250 messages per second. A message can be sent reliably <span style="color: red"> if </span> <span style="color: red"> it </span> <span style="color: red"> is </span> <span style="color: red"> of </span> type Confirmable (CON), a response will be provided with the Acknowledgement message (ACK) type <span style="color: red"> with </span> <span style="color: red"> the </span> <span style="color: red"> same </span> <span style="color: red"> Message </span> <span style="color: red"> ID </span> or with the Reset message (RST) if the receiver <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> process </span> <span style="color: red"> the </span> <span style="color: red"> message </span> sent. This process can be seen in Fig. 3. A non-reliable message can be sent as Nonconfirmable message (NON) that won’t have any acknowledge response, but if the recipient has some troubles processing such message, it can reply with the Reset message (RST). Even if these messages are unreliable, they have a unique ID. This process can be seen in Fig. 4. CoAP message types <span style="color: red"> are </span> <span style="color: red"> summarized </span> <span style="color: red"> in </span> <span style="color: red"> Table </span> 2.  III. C ONSTRAINED A PPLICATION P ROTOCOL (C OAP) The way CoAP interact is very similar to the HTTP client/server model, but is common to use a node performing both client and server. A CoAP request <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> by </span> <span style="color: red"> a </span> <span style="color: red"> client </span> <span style="color: red"> to </span> <span style="color: red"> a </span> server in order to request an action (specified with a Method Code parameter) on a particular resource identified by an URI. Then the server returns a response containing a Response Code, with the resource or an error message. CoAP differs from HTTP when dealing these messages exchanges because it handles them asynchronously over the transport layer (in this case the UDP, in section VI we will see how CoAP works over TCP). 4 types of message are supported by CoAP: Confirmable, Non-confirmable, Acknowledgement and Reset. Those messages can transport request or responses based on their Method Codes or Response  2  Name  Data size (eg. RAM)  Code Size (eg. ROM)  Class 0, C0   10KB   100KB  Class 1, C1  ∼10KB  ∼100KB  Class 2, C2  ∼50KB  ∼250KB  Functionality Very constrained devices. Cannot communicate with the Internet directly. IP and security capable, cannot easily communicate using full IP stacks, such as HTTP. May be able to use CoAP over UDP. Support most protocol stacks.  TABLE 1: Classification of constrained devices Message type Confirmable Non-Confirmable Reset Acknowledgment  Description Reliable message delivery, the recipient is required to confirm with an acknowledgment Not acknowledged, delivery is not guaranteed Indicates that a message was received, but the <span style="color: red"> recipient </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> process </span> it Indicates that the message was received and processed correctly TABLE 2: CoAP message types  sponse. This process can be seen in Fig. 5.  Fig. 3: Reliable message transmission  Fig. 5: Example of GET Requests that receive Piggybacked Responses <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> server </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> respond </span> <span style="color: red"> immediately </span> <span style="color: red"> to </span> the Confirmable message, it sends back and empty ACK message, otherwise the client will continue to retransmit the request. And when it’s ready to respond, it sends <span style="color: red"> a </span> <span style="color: red"> Confirmable </span> <span style="color: red"> message </span> <span style="color: red"> with </span> the content that must be confirmed with an ACK message from the client. This mechanism is called ”separate response” and can be seen in Fig. 6. Instead, <span style="color: red"> if </span> <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> is </span> sent by using a Nonconfirmable message (NON), the response is sent also as Non-confirmable that you can see in Fig. 7.  Fig. 4: Unreliable message transmission B. Request/Response Model The CoAP Request/Response is the top abstract layer. Request and responses are carried by the CoAP messages, that includes <span style="color: red"> a </span> <span style="color: red"> Method </span> <span style="color: red"> Code </span> <span style="color: red"> or </span> a Response code. A <span style="color: red"> Token </span> <span style="color: red"> is </span> <span style="color: red"> used </span> <span style="color: red"> to </span> pair <span style="color: red"> the </span> <span style="color: red"> response </span> <span style="color: red"> to </span> <span style="color: red"> the </span> corresponding request. The request <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> using </span> <span style="color: red"> a </span> <span style="color: red"> Confirmable </span> <span style="color: red"> (CON) </span> <span style="color: red"> or </span> <span style="color: red"> Non-confirmable </span> <span style="color: red"> (NON) </span> message. <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> is </span> <span style="color: red"> sent </span> <span style="color: red"> by </span> <span style="color: red"> a </span> Confirmable message, <span style="color: red"> the </span> <span style="color: red"> server </span> <span style="color: red"> responds </span> <span style="color: red"> with </span> an Acknowledgement (ACK) message with the resource or with an Error Code, this is called piggybacked Re-  C. Intermediaries, Caching and Resource Discovery To fulfill request efficiently CoAP offer the caching of responses. Since we are working on constrained networks, CoAP also offer the possibility of creating a proxy, this is due to restrain network traffic, boost performances, to access to the data of devices in sleep mode, and to provide security. Like in HTTP proxying,  3  IV. M ESSAGE F ORMAT, T RANSMISSION AND S EMANTIC In this section we are going to cover the CoAP message format. Since this protocol was created to work on constrained networks, it uses compact messages and, to avoid the fragmentation, it occupies the data section of just one UDP datagram, but it can also be transported over TCP. A. Message Format The message format is composed by a 4-byte header, followed by a Token value which length is specified in the TKL header field (0 to 8 bytes), as said before this token <span style="color: red"> is </span> <span style="color: red"> used </span> <span style="color: red"> to </span> <span style="color: red"> match </span> requests and responses. Then <span style="color: red"> a </span> <span style="color: red"> sequence </span> <span style="color: red"> of </span> <span style="color: red"> 0 </span> or more options in the Type-Length-Value (TLV) format. An Option might <span style="color: red"> be </span> <span style="color: red"> followed </span> <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> end </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> message, </span> <span style="color: red"> by </span> <span style="color: red"> another </span> <span style="color: red"> Option, </span> <span style="color: red"> or </span> <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> Payload </span> <span style="color: red"> Marker </span> (0xFF) <span style="color: red"> which </span> <span style="color: red"> indicates </span> <span style="color: red"> the </span> <span style="color: red"> end </span> <span style="color: red"> of </span> <span style="color: red"> options </span> <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> start </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> payload </span> that can take <span style="color: red"> the </span> <span style="color: red"> rest </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> datagram </span> size. This format can be seen in Fig. 9. In particular the header fields are defined as follow:  Fig. 6: <span style="color: red"> A </span> <span style="color: red"> GET </span> <span style="color: red"> Request </span> <span style="color: red"> with </span> <span style="color: red"> a </span> <span style="color: red"> Separate </span> <span style="color: red"> Response </span> <span style="color: red">  </span> • •  •  •  Fig. 7: <span style="color: red"> A </span> <span style="color: red"> Request </span> <span style="color: red"> and </span> <span style="color: red"> a </span> <span style="color: red"> Response </span> <span style="color: red"> Carried </span> <span style="color: red"> in </span> Nonconfirmable Messages • <span style="color: red">  </span> <span style="color: red"> the </span> <span style="color: red"> destination </span> <span style="color: red"> IP </span> <span style="color: red"> address </span> is <span style="color: red"> the </span> <span style="color: red"> address </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> while the resource’s URI is inside the request. There is also the possibility to map <span style="color: red"> CoAP </span> <span style="color: red"> to </span> <span style="color: red"> HTTP </span> <span style="color: red"> and </span> the other way around. This conversion can be realized by a cross-proxy (a cross-protocol proxy) that converts Method/Response codes, options o the corresponding in HTTP. As final note of this section, since <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> context </span> <span style="color: red"> of </span> M2M interactions Resource Discovery is pretty important, CoAP support it <span style="color: red"> using </span> <span style="color: red"> the </span> <span style="color: red"> CoRE </span> <span style="color: red"> Link </span> Format.  Version (Ver): 2-bit unsigned integer. Type (T): 2-bit unsigned integer. <span style="color: red"> Confirmable </span> <span style="color: red"> (0), </span> <span style="color: red"> Non-confirmable </span> <span style="color: red"> (1), </span> <span style="color: red"> Acknowledgement </span> <span style="color: red"> (2), </span> <span style="color: red"> or </span> Reset (3) Token Length (TKL): 4-bit unsigned integer. <span style="color: red"> Indicates </span> <span style="color: red"> the </span> <span style="color: red"> length </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> variable-length </span> <span style="color: red"> Token </span> <span style="color: red"> field </span> <span style="color: red"> (0-8 </span> <span style="color: red"> bytes). </span> Lengths 9-15 are <span style="color: red"> reserved, </span> <span style="color: red"> MUST </span> <span style="color: red"> NOT </span> <span style="color: red"> be </span> <span style="color: red"> sent, </span> <span style="color: red"> and </span> <span style="color: red"> MUST </span> <span style="color: red"> be </span> <span style="color: red"> processed </span> <span style="color: red"> as </span> <span style="color: red"> a </span> <span style="color: red"> message </span> <span style="color: red"> format </span> <span style="color: red"> error. </span> Code: <span style="color: red"> 8-bit </span> <span style="color: red"> unsigned </span> <span style="color: red"> integer, </span> <span style="color: red"> split </span> <span style="color: red"> into </span> <span style="color: red"> a </span> <span style="color: red"> 3-bit </span> <span style="color: red"> class </span> <span style="color: red"> (most </span> <span style="color: red"> significant </span> <span style="color: red"> bits) </span> <span style="color: red"> and </span> <span style="color: red"> a </span> <span style="color: red"> 5-bit </span> <span style="color: red"> detail </span> <span style="color: red"> (least </span> <span style="color: red"> significant </span> bits). Class <span style="color: red"> can </span> <span style="color: red"> indicate </span> <span style="color: red"> a </span> <span style="color: red"> request </span> <span style="color: red"> (0), </span> <span style="color: red"> a </span> <span style="color: red"> success </span> <span style="color: red"> response </span> <span style="color: red"> (2), </span> <span style="color: red"> a </span> <span style="color: red"> client </span> <span style="color: red"> error </span> <span style="color: red"> response </span> <span style="color: red"> (4), </span> <span style="color: red"> or </span> <span style="color: red"> a </span> <span style="color: red"> server </span> <span style="color: red"> error </span> response (5). <span style="color: red"> Code </span> <span style="color: red"> 0.00 </span> <span style="color: red"> indicates </span> <span style="color: red"> an </span> <span style="color: red"> Empty </span> <span style="color: red"> message. </span> <span style="color: red"> In </span> <span style="color: red"> case </span> <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> request, </span> <span style="color: red"> the </span> <span style="color: red"> Code </span> <span style="color: red"> field </span> <span style="color: red"> indicates </span> <span style="color: red"> the </span> <span style="color: red"> Request </span> <span style="color: red"> Method; </span> <span style="color: red"> in </span> <span style="color: red"> case </span> <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> response, </span> <span style="color: red"> a </span> <span style="color: red"> Response </span> <span style="color: red"> Code. </span> Message ID: <span style="color: red"> 16-bit </span> <span style="color: red"> unsigned </span> <span style="color: red"> integer </span> <span style="color: red"> in </span> <span style="color: red"> network </span> <span style="color: red"> byte </span> <span style="color: red"> order. </span> <span style="color: red">  </span> The option format requires to each option instance to specify <span style="color: red"> the </span> <span style="color: red"> Option </span> <span style="color: red"> Number </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> CoAP </span> <span style="color: red"> option, </span> <span style="color: red"> the </span> <span style="color: red"> length </span> <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> Option </span> <span style="color: red"> Value </span> <span style="color: red"> and </span> the Option Value itself. More than one instance <span style="color: red"> of </span> <span style="color: red"> the </span> <span style="color: red"> same </span> <span style="color: red"> option </span> <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> used </span> by specifying an option delta of zero. We don’t go deeper in this concept because its quite complicated and long, we limit ourselves to show the structure in Fig. 8, for further information, read the RFC7252 [2].  4  a RST message. Messages transmitted without reliability: usually this are messages that are sent regularly, like <span style="color: red"> readings </span> <span style="color: red"> from </span> <span style="color: red"> a </span> <span style="color: red"> sensor </span> where the <span style="color: red"> eventual </span> <span style="color: red"> success </span> <span style="color: red"> is </span> <span style="color: red"> sufficient. </span> Those kinds of messages can be sent marking the proper header field as Non-Confirmable (NON) message. This kind of messages must not be empty. C. Message semantic CoAP uses <span style="color: red"> a </span> <span style="color: red"> similar </span> <span style="color: red"> request/response </span> <span style="color: red"> model </span> of HTTP, basically a client <span style="color: red"> sends </span> <span style="color: red"> one </span> <span style="color: red"> or </span> <span style="color: red"> more </span> <span style="color: red"> CoAP </span> <span style="color: red"> requests </span> <span style="color: red"> to </span> <span style="color: red"> a </span> server, which sends back CoAP responses. But, unlike HTTP, those request <span style="color: red"> and </span> <span style="color: red"> responses </span> <span style="color: red"> are </span> <span style="color: red"> not </span> <span style="color: red"> sent </span> after a pre-established connection, there are sent asynchronously. Requests: consist of a <span style="color: red"> method </span> <span style="color: red"> to </span> <span style="color: red"> be </span> <span style="color: red"> applied </span> <span style="color: red"> to </span> a specific resource, the resource identifier, the payload and the internet media type (if any), and the <span style="color: red"> metadata </span> <span style="color: red"> about </span> <span style="color: red"> the </span> <span style="color: red"> request </span> (optional). The methods supported by CoAP are <span style="color: red"> GET, </span> <span style="color: red"> POST, </span> <span style="color: red"> PUT, </span> <span style="color: red"> and </span> DELETE. They are safe (only on retrieval) and idempotent (when invoked multiple times have the same effect) like for the equivalent HTTP. Responses: they are matched with the request by a Token generated by the client. They are <span style="color: red"> identified </span> <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> Code </span> <span style="color: red"> field </span> <span style="color: red"> in </span> <span style="color: red"> the </span> header. Like for <span style="color: red"> the </span> <span style="color: red"> HTTP </span> <span style="color: red"> Status </span> <span style="color: red"> Code </span> <span style="color: red"> the </span> <span style="color: red"> CoAP </span> <span style="color: red"> Response </span> <span style="color: red"> Code </span> <span style="color: red"> indicates </span> <span style="color: red"> the </span> <span style="color: red"> result </span> <span style="color: red"> of </span> trying to satisfy the client request. The 8-bit Response Code (Fig. 10) define the class (3-bit) and the detail (5-bit) of the response. There are 3 main classes of Response Code: • 2 - Success: indicates <span style="color: red"> that </span> <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> was </span> <span style="color: red"> successfully </span> <span style="color: red"> received, </span> <span style="color: red"> understood </span> and accepted. • <span style="color: red"> 4 </span> <span style="color: red"> - </span> <span style="color: red"> Client </span> <span style="color: red"> Error: </span> the <span style="color: red"> request </span> <span style="color: red"> contains </span> <span style="color: red"> bad </span> <span style="color: red"> syntax </span> <span style="color: red"> or </span> <span style="color: red"> cannot </span> <span style="color: red"> be </span> fulfilled • <span style="color: red"> 5 </span> <span style="color: red"> - </span> <span style="color: red"> Server </span> <span style="color: red"> Error: </span> the <span style="color: red"> server </span> <span style="color: red"> failed </span> <span style="color: red"> to </span> <span style="color: red"> fulfill </span> <span style="color: red"> an </span> <span style="color: red"> apparently </span> <span style="color: red"> valid </span> request  Fig. 8: CoAP Message Option Format B. Message Transmission CoAP messages <span style="color: red"> are </span> <span style="color: red"> used </span> <span style="color: red"> to </span> <span style="color: red"> transport </span> request and responses between CoAP endpoints, and they are exchange asynchronously. Since UDP is not reliable transport protocol, those messages may not arrive in order, they can be missing or can be duplicated. So, CoAP uses a small mechanism to assure reliability that can detect duplicates for both Confirmable (CON) and NonConfirmable (NON) messages, and implements a simple <span style="color: red"> stop-and-wait </span> <span style="color: red"> retransmission </span> <span style="color: red"> reliability </span> <span style="color: red"> with </span> <span style="color: red"> exponential </span> <span style="color: red"> back-off </span> <span style="color: red"> for </span> <span style="color: red"> Confirmable </span> <span style="color: red"> messages. </span> Messages and Endpoints: an <span style="color: red"> endpoint </span> <span style="color: red"> is </span> <span style="color: red"> the </span> <span style="color: red"> source </span> <span style="color: red"> or </span> <span style="color: red"> destination </span> <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> CoAP </span> <span style="color: red"> message </span> and <span style="color: red"> is </span> <span style="color: red"> identified </span> <span style="color: red"> by </span> <span style="color: red"> an </span> <span style="color: red"> IP </span> <span style="color: red"> address </span> <span style="color: red"> and </span> <span style="color: red"> a </span> <span style="color: red"> UDP </span> <span style="color: red"> port </span> <span style="color: red"> number. </span> As we say, there are various types of messages, those messages can <span style="color: red"> carry </span> <span style="color: red"> a </span> <span style="color: red"> request, </span> <span style="color: red"> a </span> <span style="color: red"> response </span> <span style="color: red"> or </span> <span style="color: red"> be </span> empty. If a message is empty, it’s Code field must be set to 0.00, <span style="color: red"> the </span> <span style="color: red"> Token </span> <span style="color: red"> Length </span> <span style="color: red"> field </span> (TKL) to 0 and id there are bytes present in the payload, they are interpreted as error message. Messages Transmitted Reliably: the message must be marked as Confirmable (CON) in the proper header field. This kind of message always carries a request, a response or a Reset, so a receiver must return an ACK or reject it. The rejection of a confirmable message contains <span style="color: red"> the </span> <span style="color: red"> Message </span> <span style="color: red"> ID </span> <span style="color: red"> and </span> the payload is empty. The sender keeps retransmitting the message at increasing intervals <span style="color: red"> until </span> <span style="color: red"> it </span> <span style="color: red"> receives </span> <span style="color: red"> an </span> ACK, a RST or reach the limit of attempts. The <span style="color: red"> initial </span> <span style="color: red"> timeout </span> <span style="color: red"> is </span> <span style="color: red"> set </span> <span style="color: red"> to </span> <span style="color: red"> a </span> <span style="color: red"> random </span> <span style="color: red"> duration </span> between ACK_TIMEOUT (default is 2 seconds) <span style="color: red"> and </span> <span style="color: red"> (ACK_TIMEOUT </span> <span style="color: red"> * </span> <span style="color: red"> ACK_RANDOM_FACTOR </span> (default is 1.5)), <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> retransmission </span> <span style="color: red"> counter </span> starts from 0. When the timeout is reached <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> retransmission </span> <span style="color: red"> counter </span> <span style="color: red"> is </span> <span style="color: red"> less </span> <span style="color: red"> than </span> MAX_RETRANSMIT (default is 4), the message is sent again, <span style="color: red"> the </span> <span style="color: red"> retransmission </span> <span style="color: red"> counter </span> <span style="color: red"> is </span> <span style="color: red"> incremented, </span> <span style="color: red"> and </span> <span style="color: red"> the </span> <span style="color: red"> timeout </span> <span style="color: red"> is </span> <span style="color: red"> doubled. </span> This continues until the counter reach MAX_RETRANSMIT or the sender receive  V. C OAP M ETHODS , C ACHING AND P ROXYING A. Method definitions Resources <span style="color: red"> are </span> <span style="color: red"> organized </span> <span style="color: red"> hierarchically </span> <span style="color: red"> and </span> <span style="color: red"> governed </span> <span style="color: red"> by </span> <span style="color: red"> a </span> <span style="color: red"> potential </span> <span style="color: red"> CoAP </span> <span style="color: red"> origin </span> <span style="color: red"> server </span> <span style="color: red"> listening </span> <span style="color: red"> for </span> <span style="color: red"> CoAP </span> <span style="color: red"> requests </span> (”coap” or ”coaps”). CoAP URI scheme is defined as follows: coap-URI = ”coap:” ”//” host [ ”:” <span style="color: red"> port </span> <span style="color: red"> ] </span> <span style="color: red"> path-abempty </span> <span style="color: red"> [ </span> ”?” query ] Where HOST must not be empty and PORT indicates the UDP port, if it’s empty the default 5683 is used. CoAP implements methods, very similar to HTTP, with which clients can call an action on a specific resource identified the previously mentioned URIs. A request with a method that is not supported, returns a 4.05  5  Fig. 9: CoAP Message Format  B. Caching We just briefly note that CoAP endpoints have the possibility to cache the <span style="color: red"> responses </span> <span style="color: red"> in </span> <span style="color: red"> order </span> <span style="color: red"> to </span> <span style="color: red"> reduce </span> <span style="color: red"> the </span> <span style="color: red"> response </span> time and bandwidth usage. The main purpose <span style="color: red"> of </span> <span style="color: red"> caching </span> <span style="color: red"> in </span> <span style="color: red"> CoAP </span> <span style="color: red"> is </span> <span style="color: red"> to </span> <span style="color: red"> reuse </span> <span style="color: red"> a </span> response message to <span style="color: red"> satisfy </span> <span style="color: red"> a </span> <span style="color: red"> current </span> <span style="color: red"> request </span> that <span style="color: red"> is </span> <span style="color: red"> equivalent </span> <span style="color: red"> to </span> <span style="color: red"> a </span> past one. The cacheability of a response <span style="color: red"> depends </span> <span style="color: red"> on </span> <span style="color: red"> the </span> <span style="color: red"> Response </span> <span style="color: red"> Code. </span> <span style="color: red">  </span> Fig. 10: <span style="color: red"> Structure </span> <span style="color: red"> of </span> <span style="color: red"> a </span> <span style="color: red"> Response </span> <span style="color: red"> Code </span> (Method Not Allowed) response. The methods supported by CoAP are: •  •  •  •  GET: <span style="color: red"> retrieves </span> <span style="color: red"> a </span> <span style="color: red"> representation </span> <span style="color: red"> for </span> <span style="color: red"> the </span> resources identified by the URI. If this is possible, the server returns a 2.03 (Valid) or 2.05 (Content) Response Code. This method is safe (it <span style="color: red"> MUST </span> <span style="color: red"> NOT </span> <span style="color: red"> take </span> <span style="color: red"> any </span> <span style="color: red"> other </span> <span style="color: red"> action </span> <span style="color: red"> on </span> <span style="color: red"> a </span> resource other than retrieval) and idempotent. POST: results in a creation, update or deletion of a resource. If a resource is created, the server returns s <span style="color: red"> 2.01 </span> <span style="color: red"> (Created) </span> <span style="color: red"> Response </span> <span style="color: red"> Code </span> with the URI. If there is an update of the resource, the server returns <span style="color: red"> a </span> <span style="color: red"> 2.04 </span> <span style="color: red"> (Changed) </span> <span style="color: red"> Response </span> <span style="color: red"> Code. </span> Instead, if a resource is deleted, the server returns <span style="color: red"> a </span> <span style="color: red"> 2.02 </span> <span style="color: red"> (Deleted) </span> <span style="color: red"> Response </span> <span style="color: red"> Code. </span> POST is not safe and not idempotent. Is not idempotent <span style="color: red"> because </span> <span style="color: red"> its </span> <span style="color: red"> effect </span> <span style="color: red"> is </span> <span style="color: red"> determined </span> <span style="color: red"> by </span> <span style="color: red"> the </span> <span style="color: red"> origin </span> <span style="color: red"> server </span> <span style="color: red"> and </span> <span style="color: red"> dependent </span> <span style="color: red"> on </span> <span style="color: red"> the </span> <span style="color: red"> target </span> resource. PUT: result in the creation or update of the resource specified by the URI given. The response codes are the same as POST. <span style="color: red"> PUT </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> safe </span> <span style="color: red"> but </span> <span style="color: red"> is </span> <span style="color: red"> idempotent. </span> DELETE: results in the deletion of <span style="color: red"> the </span> <span style="color: red"> resource </span> <span style="color: red"> identified </span> <span style="color: red"> by </span> <span style="color: red"> the </span> URI given. If succeed, <span style="color: red"> a </span> <span style="color: red"> 2.02 </span> <span style="color: red"> (Deleted) </span> <span style="color: red"> Response </span> code is returned. <span style="color: red"> DELETE </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> safe </span> <span style="color: red"> but </span> <span style="color: red"> is </span> <span style="color: red"> idempotent. </span>  C. Proxying Proxies can serve many different purposes; we can distinguish them in 3 main types: • Forward-proxies: CoAP request on such proxies can be made as Confirmable (CON) or NonConfirmable (NON), but <span style="color: red"> the </span> <span style="color: red"> request </span> <span style="color: red"> URI </span> <span style="color: red"> is </span> <span style="color: red"> specified </span> <span style="color: red"> as </span> <span style="color: red"> a </span> <span style="color: red"> string </span> <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> Proxy-Uri </span> <span style="color: red"> Option </span> instead of being split in URI-Host, URI-Port, URI-Path and URI-Query Options. If the endpoint <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> <span style="color: red"> act </span> <span style="color: red"> as </span> <span style="color: red"> a </span> proxy, it returns <span style="color: red"> a </span> <span style="color: red"> 5.05 </span> <span style="color: red"> (Proxying </span> <span style="color: red"> Not </span> <span style="color: red"> Supported) </span> <span style="color: red"> response. </span> • Reverse-Proxies: offer various <span style="color: red"> resources </span> <span style="color: red"> as </span> <span style="color: red"> if </span> <span style="color: red"> they </span> <span style="color: red"> were </span> <span style="color: red"> its </span> <span style="color: red"> own </span> resources. • Cross-Proxies: can translate a CoAP request/response to a different protocol. More specifically, a particular kind of cross-proxying is of interest in IoT when using CoAP, that is the CrossProtocol <span style="color: red"> Proxying </span> <span style="color: red"> between </span> <span style="color: red"> CoAP </span> <span style="color: red"> and </span> <span style="color: red"> HTTP, </span> that’s because CoAP support <span style="color: red"> a </span> <span style="color: red"> limited </span> <span style="color: red"> subset </span> <span style="color: red"> of </span> <span style="color: red"> HTTP </span> functionalities. Only <span style="color: red"> the </span> <span style="color: red"> request/response </span> <span style="color: red"> model </span> <span style="color: red"> of </span> <span style="color: red"> CoAP </span> <span style="color: red"> is </span> <span style="color: red"> mapped </span> <span style="color: red"> to </span> HTTP. The Confirmable/Non-confirmable messages model is invisible and has <span style="color: red"> no </span> <span style="color: red"> effect </span> <span style="color: red"> on </span> <span style="color: red"> a </span> <span style="color: red"> proxy </span> function. CoAP-HTTP Proxying: enables <span style="color: red"> CoAP </span> <span style="color: red"> clients </span> <span style="color: red"> to </span> <span style="color: red"> access </span> <span style="color: red"> resources </span> that are hosted on a HTTP server. When sending a request to the CoAP-HTTP proxy, a CoAP client has to set the Proxy-URI or Proxy-Scheme Option to ”http” or ”https”. Since <span style="color: red"> the </span> <span style="color: red"> basic </span> <span style="color: red"> methods </span> <span style="color: red"> of </span> CoAP are very similar to HTTP, performing a request is not much different. <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> service the  The difference between POST and PUT is that PUT in generally used to replace the existing content of a resource, while POST is used to send new data. Some other IoT frameworks uses the use of CRUD methods (CREATE, RETRIEVE, UPDATE, DELETE) to overcome this ambiguity. A brief summary of CoAP methods can also be seen in Table 3.  6  Methods GET PUT POST DELETE  Description Retrieves a representation of information corresponding to the specified URI Requests to update the identified resource be updated with the enclosed representation, or create new Request to process the enclosed representation Delete <span style="color: red"> the </span> <span style="color: red"> resource </span> <span style="color: red"> identified </span> <span style="color: red"> by </span> <span style="color: red"> the </span> URI TABLE 3: CoAP methods  Messaging Model: since TCP provides reliable transmission, CoAP Confirmable and Acknowledge message are no longer needed. So, the type field and Message ID field <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> header </span> <span style="color: red"> are </span> not present anymore, instead the fields for expressing <span style="color: red"> the </span> <span style="color: red"> length </span> <span style="color: red"> of </span> <span style="color: red"> the </span> message (Length and Extended Length) are present because TCP does not provide this information. Message Format: is very similar of the one over UDP, except for type, Message ID and Version fields that are removed as previously said. This format can be seen in Fig. 11. Message Transmission: after the TCP connection is established, the CoAP endpoints send a CSM (Capabilities and Settings Message) as first message of the connection. This special message initializes the settings and capabilities of the endpoints, if there are no options set in this message, the defaults are used. Request and response are sent asynchronously over the Transport Connection. So, a client can send multiple requests without waiting for responses, and those responses can be returned in any order but in the same connection. The TCP protocol is bidirectional, this implies that requests <span style="color: red"> and </span> <span style="color: red"> responses </span> <span style="color: red"> can </span> <span style="color: red"> be </span> sent by both endpoints. TCP also support retransmission and deduplication of messages. <span style="color: red">  </span> <span style="color: red"> request </span> <span style="color: red"> with </span> <span style="color: red"> the </span> HTTP URI, it returns <span style="color: red"> a </span> <span style="color: red"> 5.05 </span> <span style="color: red"> (Proxying </span> <span style="color: red"> Not </span> <span style="color: red"> Supported) </span> <span style="color: red"> response. </span> <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> unable </span> to get the requested resource by the HTTP server in a given timeframe, it returns <span style="color: red"> a </span> <span style="color: red"> 5.04 </span> <span style="color: red"> (Gateway </span> <span style="color: red"> Timeout) </span> response. If the resource is not understood, it returns <span style="color: red"> a </span> <span style="color: red"> 5.02 </span> <span style="color: red"> (Bad </span> <span style="color: red"> Gateway) </span> <span style="color: red"> response. </span> The response payload must <span style="color: red"> be </span> <span style="color: red"> a </span> <span style="color: red"> representation </span> <span style="color: red"> of </span> <span style="color: red"> the </span> HTTP resource, and the ContentFormat Option should be set accordingly. HTTP-CoAP Proxying: enables <span style="color: red"> HTTP </span> <span style="color: red"> clients </span> <span style="color: red"> to </span> <span style="color: red"> access </span> <span style="color: red"> resources </span> hosted on CoAP servers. When sending a request to the HTTP-CoAP proxy, an HTTP client has to set the Request-Line to ”coap” or ”coaps”. <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> service the request with the CoAP URI, it returns <span style="color: red"> a </span> <span style="color: red"> 501 </span> <span style="color: red"> (Not </span> <span style="color: red"> Implemented) </span> response. <span style="color: red"> If </span> <span style="color: red"> the </span> <span style="color: red"> proxy </span> <span style="color: red"> is </span> <span style="color: red"> not </span> <span style="color: red"> able </span> <span style="color: red"> to </span> get the requested resource by the CoAP server in a given timeframe, it returns <span style="color: red"> a </span> <span style="color: red"> 504 </span> <span style="color: red"> (Gateway </span> <span style="color: red"> Timeout) </span> response. If the resource is not understood, it returns a 502 (Bad Gateway) response. Since the methods OPTION, TRACE and CONNECT are not implemented in CoAP, if those one are called, the proxy returns <span style="color: red"> a </span> <span style="color: red"> 501 </span> <span style="color: red"> (Not </span> <span style="color: red"> Implemented) </span> error. VI. C OAP ENHANCEMENTS In this section we are going to review some enhancements and extensions of the standard CoAP protocol. In particular we explore the CoAP over TCP and CoAP for streaming.  B. CoAP for Streaming In the last years, a variety of streaming application in IoT are becoming more common, in this paper the authors explore the usage of the CoAP protocol for this task. The conventional CoAP over UDP and CoAP over TCP schemes <span style="color: red"> can </span> <span style="color: red"> be </span> <span style="color: red"> used </span> <span style="color: red"> for </span> reliable services as we seen. However, they do not provide error handling and flow controls suitable to facilitate the streaming data transmission at the sender, this leads to a degradation of the throughput performances, especially in sensor wireless lossy networks. For example, if in CoAP over UDP a message gets lost, its retransmission will happen after a timeout, making the error recovery to increase transmission delays. In CoAP over TCP the packet can be recovered quickly using the TCP fast recovery, but this mechanism adds overhead in the IoT environment. Moreover, the complexity of TCP is not very suitable for  A. CoAP over TCP The standard CoAP operates above the User Datagram Protocol (UDP) accomplishing lightweight messaging. But the main downsides are that UDP cannot provide reliability and some networks, especially enterprise networks, do not froward UDP packets. For those reasons and that the demand for the use of TCP in IoT is increasing, CoAP over TCP was proposed [3]. TCP has congestion control and flow control mechanism, more sophisticated that the one of CoAP over UDP, but uses a larger packet size, more round trips, and increased RAM requirements. The main difference between CoAP over TCP and over UDP is on the message layer, while the request/response model remains the same.  7  Fig. 11: CoAP over TCP Message Format  real time streaming in IoT environment. To overcome these problems, the authors [4] proposed a CoAP-based streaming control (CoAP-SC), which is an extension of CoAP over UDP with error handling and flow controls for throughput enhancement. The scheme is designed by assigning a sequence number (SN) to each data message, and an ACK number (AN) is returned by the receiver. Initialization for CoAP-SC: with a POST message the sender requests the creation of a new resource, this request include authentication information, buffer size and other parameters associated with the streaming service. After the creation of the resource, the receiver returns a 2.01 response message with the URL of this new resource. Then, the sender sends <span style="color: red"> a </span> <span style="color: red"> GET </span> <span style="color: red"> request </span> <span style="color: red"> to </span> that URL, and the receiver responds back with a 2.05 response message. All GET and their response messages contains a sequence number (SN) and ACK number (AN), where SN is sequentially assigned on each message sent by the sender, and the AN is set by the receiver to tell that that message was received correctly. The AN is cumulative. In the initialization process SN and AN are set to 0. This initialization process can be seen in Fig 12. Error Handling for CoAP-SC: the first message sent by the sender has SN=1 and AN=0. Each time the receiver gets a <span style="color: red"> message </span> <span style="color: red"> from </span> <span style="color: red"> the </span> <span style="color: red"> sender, </span> it updates its own AN number to be equal to the largest SN value that has been received and cumulatively. So, if the receiver <span style="color: red"> does </span> <span style="color: red"> not </span> <span style="color: red"> receive </span> <span style="color: red"> any </span> data message for a certain amount of time, it sends an ACK message to tell <span style="color: red"> the </span> <span style="color: red"> sender </span> <span style="color: red"> of </span> <span style="color: red"> the </span> AN status. In the normal streaming flow, the receiver will receive a message with SN = ANsent + 1, and the next message it will send, will have AN = SNreceived = ANsent + 1. So, if a message gets lost, the receiver will determine that by checking if this condition is true: SNreceived − ANsent > 1. When this loss is detected, the receiver sends an ACK message for a retransmission request that includes the SN of <span style="color: red"> the </span> <span style="color: red"> message </span> <span style="color: red"> to </span> <span style="color: red"> be </span> transmitted, and this ACK is retransmitted until the data lost is correctly received. An example of  Fig. 12: CoAP-SC Initialization this mechanism can be seen in Fig. 13. Flow Control for CoAP-SC: ACK messages are used also for flow control, by providing the up-to-date AN information to the sender, in this way facilitating it to transmit as much data as possible, resulting a throughput enhancement. CoAP Option for CoAP-SC: the Option header is composed by 4bit Option Delta, 4-bit Option Length, 4-byte Sequence number and 4-byte ACK number. This option format can be seen in Fig. 14. VII. C ONCLUDING R EMARKS In this paper an overview of the CoAP protocol has given. Since the basic architecture of CoAP may perform  8  Fig. 14: CoAP-SC Message Option Format mechanism to deal with errors and flow control that are crucial in streaming. <span style="color: red"> On </span> <span style="color: red"> the </span> <span style="color: red"> other </span> <span style="color: red"> hand, </span> it seems that this Streaming scheme still requires some more works to reduce the packet size for IoT environment. VIII. ACKNOWLEDGMENT This work is presented for the final grade of the ”Internet of Things and Smart Cities” course, held by prof. Lorenzo Vangelista at the University of Padova in 2021. R EFERENCES [1] M. Belshe, R. Peon, and M. Thomson, “Hypertext Transfer Protocol Version 2 (HTTP/2).” RFC 7540, May 2015. [2] Z. Shelby, K. Hartke, and C. Bormann, “The Constrained Application Protocol (CoAP).” RFC 7252, June 2014. [3] C. Bormann, S. Lemay, H. Tschofenig, K. Hartke, B. Silverajan, and B. Raymor, “CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets.” RFC 8323, Feb. 2018. [4] J.-H. Jung, M. Gohar, and S.-J. Koh, “Coap-based streaming control for iot applications,” Electronics, vol. 9, no. 8, 2020.  Fig. 13: CoAP-SC Error Handling example inefficiently in some scenarios like when strong reliability is needed and <span style="color: red"> in </span> <span style="color: red"> the </span> <span style="color: red"> case </span> <span style="color: red"> of </span> streaming applications, we proposed possible solutions for those problems taken from the most recent literature. In particular for reliability, a RFC called ”CoAP over TCP” that as its title says, modifies CoAP to work on the reliable transport protocol TCP. While for the streaming scenario, a modification called CoAP-SC was reviewed, that propose good a  9  